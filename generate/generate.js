// Generated by Haxe 4.0.0-preview.4+1e3e5e0
(function () { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = {},$_;
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var Node = function(x,y,w,h) {
	this.used = false;
	this.x = x;
	this.y = y;
	this.w = w;
	this.h = h;
};
Node.__name__ = true;
var BinPacker = function() { };
BinPacker.__name__ = true;
BinPacker.fit = function(blocks,w,h) {
	var sortedBlocks = blocks.slice();
	sortedBlocks.sort(function(a,b) {
		if(Math.max(a.w,a.h) > Math.max(b.w,b.h)) {
			return 1;
		} else {
			return -1;
		}
	});
	var fits = [];
	var root = new Node(0,0,w,h);
	var _g = 0;
	while(_g < sortedBlocks.length) {
		var block = sortedBlocks[_g];
		++_g;
		var node = BinPacker.findNode(root,block.w,block.h);
		fits[blocks.indexOf(block)] = node != null ? BinPacker.splitNode(node,block.w,block.h) : null;
	}
	return fits;
};
BinPacker.findNode = function(parent,w,h) {
	if(parent.used) {
		var right = BinPacker.findNode(parent.right,w,h);
		if(right != null) {
			return right;
		} else {
			return BinPacker.findNode(parent.down,w,h);
		}
	} else if(w <= parent.w && h <= parent.h) {
		return parent;
	}
	return null;
};
BinPacker.splitNode = function(node,w,h) {
	node.used = true;
	node.down = new Node(node.x,node.y + h,node.w,node.h - h);
	node.right = new Node(node.x + w,node.y,node.w - w,h);
	return node;
};
var js_node_ChildProcess = require("child_process");
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Sys = function() { };
Sys.__name__ = true;
Sys.environment = function() {
	var m = new haxe_ds_StringMap();
	var _g = 0;
	var _g1 = Reflect.fields(process.env);
	while(_g < _g1.length) {
		var key = _g1[_g];
		++_g;
		var v = process.env[key];
		if(__map_reserved[key] != null) {
			m.setReserved(key,v);
		} else {
			m.h[key] = v;
		}
	}
	return m;
};
Sys.systemName = function() {
	var _g = process.platform;
	switch(_g) {
	case "darwin":
		return "Mac";
	case "freebsd":
		return "BSD";
	case "linux":
		return "Linux";
	case "win32":
		return "Windows";
	default:
		return _g;
	}
};
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.deleteField = function(o,field) {
	if(!Object.prototype.hasOwnProperty.call(o,field)) {
		return false;
	}
	delete(o[field]);
	return true;
};
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw new js__$Boot_HaxeError("EReg::matched");
		}
	}
	,matchedRight: function() {
		if(this.r.m == null) {
			throw new js__$Boot_HaxeError("No string matched");
		}
		var sz = this.r.m.index + this.r.m[0].length;
		return HxOverrides.substr(this.r.s,sz,this.r.s.length - sz);
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw new js__$Boot_HaxeError("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b1 = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b1) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b1;
		}
	}
	,map: function(s,f) {
		var offset = 0;
		var buf_b = "";
		while(true) {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			var p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
			if(!this.r.global) {
				break;
			}
		}
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
};
var Console = function() { };
Console.__name__ = true;
Console.format = function(s,formatMode) {
	s += "<//>";
	var activeFormatFlagStack = [];
	var groupedProceedingTags = [];
	var browserFormatArguments = [];
	return { formatted : Console.formatTagPattern.map(s,function(e) {
		if(e.matched(1) != null) {
			return e.matched(0);
		}
		var open = e.matched(2) == null;
		var tags = e.matched(3).split(",");
		if(!open && tags.length == 1) {
			if(tags[0] == "") {
				var i = activeFormatFlagStack.indexOf(activeFormatFlagStack[activeFormatFlagStack.length - 1]);
				if(i != -1) {
					var proceedingTags = groupedProceedingTags[i];
					activeFormatFlagStack.splice(i - proceedingTags,proceedingTags + 1);
					groupedProceedingTags.splice(i - proceedingTags,proceedingTags + 1);
				}
			} else if(_$Console_FormatFlag_$Impl_$.fromString(tags[0]) == "reset") {
				activeFormatFlagStack = [];
				groupedProceedingTags = [];
			} else {
				var flag = _$Console_FormatFlag_$Impl_$.fromString(tags[0]);
				if(flag != null) {
					var i1 = activeFormatFlagStack.indexOf(flag);
					if(i1 != -1) {
						var proceedingTags1 = groupedProceedingTags[i1];
						activeFormatFlagStack.splice(i1 - proceedingTags1,proceedingTags1 + 1);
						groupedProceedingTags.splice(i1 - proceedingTags1,proceedingTags1 + 1);
					}
				}
			}
		} else {
			var proceedingTags2 = 0;
			var _g = 0;
			while(_g < tags.length) {
				var flag1 = _$Console_FormatFlag_$Impl_$.fromString(tags[_g++]);
				if(flag1 == null) {
					return e.matched(0);
				}
				if(open) {
					activeFormatFlagStack.push(flag1);
					groupedProceedingTags.push(proceedingTags2);
					++proceedingTags2;
				} else {
					var i2 = activeFormatFlagStack.indexOf(flag1);
					if(i2 != -1) {
						var proceedingTags3 = groupedProceedingTags[i2];
						activeFormatFlagStack.splice(i2 - proceedingTags3,proceedingTags3 + 1);
						groupedProceedingTags.splice(i2 - proceedingTags3,proceedingTags3 + 1);
					}
				}
			}
		}
		switch(formatMode) {
		case 0:
			if(open) {
				if(activeFormatFlagStack.length > 0) {
					var lastFlagCount = groupedProceedingTags[groupedProceedingTags.length - 1] + 1;
					var asciiFormatString = "";
					var _g1 = 0;
					while(_g1 < lastFlagCount) asciiFormatString += Console.getAsciiFormat(activeFormatFlagStack[groupedProceedingTags.length - 1 - _g1++]);
					return asciiFormatString;
				} else {
					return "";
				}
			} else {
				return Console.getAsciiFormat("reset") + activeFormatFlagStack.map(function(f) {
					return Console.getAsciiFormat(f);
				}).filter(function(s1) {
					return s1 != null;
				}).join("");
			}
			break;
		case 1:
			var result = activeFormatFlagStack.map(function(f1) {
				return Console.getBrowserFormat(f1);
			}).filter(function(s2) {
				return s2 != null;
			}).join(";");
			browserFormatArguments.push(result);
			return "%c";
		case 2:
			return "";
		}
	}), browserFormatArguments : browserFormatArguments};
};
Console.printFormatted = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	var result = Console.format(s,Console.formatMode);
	if(Console.formatMode == 1) {
		var logArgs = [result.formatted].concat(result.browserFormatArguments);
		switch(outputStream) {
		case 1:
			console.warn.apply(console, logArgs);
			break;
		case 2:
			console.error.apply(console, logArgs);
			break;
		case 0:case 3:
			console.log.apply(console, logArgs);
			break;
		}
		return;
	}
	Console.print(result.formatted,outputStream);
};
Console.print = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	if(Console.printIntercept != null) {
		if(!Console.printIntercept(s,outputStream)) {
			return;
		}
	}
	if(Console.unicodeCompatibilityMode == 1 && !Console.unicodeCompatibilityEnabled) {
		Console.exec("chcp 65001");
		Console.unicodeCompatibilityEnabled = true;
	}
	switch(outputStream) {
	case 1:case 2:
		new _$Sys_FileOutput(2).writeString(s);
		break;
	case 0:case 3:
		new _$Sys_FileOutput(1).writeString(s);
		break;
	}
};
Console.getAsciiFormat = function(flag) {
	if(flag.charAt(0) == "#") {
		var hex = HxOverrides.substr(flag,1,null);
		return "\x1B[38;5;" + Console.rgbToAscii256(Std.parseInt("0x" + HxOverrides.substr(hex,0,2)),Std.parseInt("0x" + HxOverrides.substr(hex,2,2)),Std.parseInt("0x" + HxOverrides.substr(hex,4,2))) + "m";
	}
	if(HxOverrides.substr(flag,0,3) == "bg#") {
		var hex1 = HxOverrides.substr(flag,3,null);
		return "\x1B[48;5;" + Console.rgbToAscii256(Std.parseInt("0x" + HxOverrides.substr(hex1,0,2)),Std.parseInt("0x" + HxOverrides.substr(hex1,2,2)),Std.parseInt("0x" + HxOverrides.substr(hex1,4,2))) + "m";
	}
	switch(flag) {
	case "bg_black":
		return "\x1B[48;5;" + 0 + "m";
	case "bg_blue":
		return "\x1B[48;5;" + 4 + "m";
	case "bg_cyan":
		return "\x1B[48;5;" + 6 + "m";
	case "bg_green":
		return "\x1B[48;5;" + 2 + "m";
	case "bg_light_black":
		return "\x1B[48;5;" + 8 + "m";
	case "bg_light_blue":
		return "\x1B[48;5;" + 12 + "m";
	case "bg_light_cyan":
		return "\x1B[48;5;" + 14 + "m";
	case "bg_light_green":
		return "\x1B[48;5;" + 10 + "m";
	case "bg_light_magenta":
		return "\x1B[48;5;" + 13 + "m";
	case "bg_light_red":
		return "\x1B[48;5;" + 9 + "m";
	case "bg_light_white":
		return "\x1B[48;5;" + 15 + "m";
	case "bg_light_yellow":
		return "\x1B[48;5;" + 11 + "m";
	case "bg_magenta":
		return "\x1B[48;5;" + 5 + "m";
	case "bg_red":
		return "\x1B[48;5;" + 1 + "m";
	case "bg_white":
		return "\x1B[48;5;" + 7 + "m";
	case "bg_yellow":
		return "\x1B[48;5;" + 3 + "m";
	case "black":
		return "\x1B[38;5;" + 0 + "m";
	case "blink":
		return "\x1B[5m";
	case "blue":
		return "\x1B[38;5;" + 4 + "m";
	case "bold":
		return "\x1B[1m";
	case "cyan":
		return "\x1B[38;5;" + 6 + "m";
	case "dim":
		return "\x1B[2m";
	case "green":
		return "\x1B[38;5;" + 2 + "m";
	case "hidden":
		return "\x1B[8m";
	case "invert":
		return "\x1B[7m";
	case "italic":
		return "\x1B[3m";
	case "light_black":
		return "\x1B[38;5;" + 8 + "m";
	case "light_blue":
		return "\x1B[38;5;" + 12 + "m";
	case "light_cyan":
		return "\x1B[38;5;" + 14 + "m";
	case "light_green":
		return "\x1B[38;5;" + 10 + "m";
	case "light_magenta":
		return "\x1B[38;5;" + 13 + "m";
	case "light_red":
		return "\x1B[38;5;" + 9 + "m";
	case "light_white":
		return "\x1B[38;5;" + 15 + "m";
	case "light_yellow":
		return "\x1B[38;5;" + 11 + "m";
	case "magenta":
		return "\x1B[38;5;" + 5 + "m";
	case "red":
		return "\x1B[38;5;" + 1 + "m";
	case "reset":
		return "\x1B[m";
	case "underline":
		return "\x1B[4m";
	case "white":
		return "\x1B[38;5;" + 7 + "m";
	case "yellow":
		return "\x1B[38;5;" + 3 + "m";
	default:
		return "";
	}
};
Console.rgbToAscii256 = function(r,g,b) {
	var nearIdx = function(c,set) {
		var delta = Infinity;
		var index = -1;
		var _g1 = 0;
		var _g = set.length;
		while(_g1 < _g) {
			var i = _g1++;
			var d = Math.abs(c - set[i]);
			if(d < delta) {
				delta = d;
				index = i;
			}
		}
		return index;
	};
	var colorSteps = [0,95,135,175,215,255];
	var ir = nearIdx(r,colorSteps);
	var ig = nearIdx(g,colorSteps);
	var ib = nearIdx(b,colorSteps);
	var jr = Math.round((r - 8) / 10);
	if(Math.abs(r - Math.max(Math.min(jr * 10 + 8,238),8)) + Math.abs(g - Math.max(Math.min(Math.round((g - 8) / 10) * 10 + 8,238),8)) + Math.abs(b - Math.max(Math.min(Math.round((b - 8) / 10) * 10 + 8,238),8)) < Math.abs(r - colorSteps[ir]) + Math.abs(g - colorSteps[ig]) + Math.abs(b - colorSteps[ib]) && r == g && g == b) {
		return jr + 232;
	} else {
		return 16 + ir * 36 + ig * 6 + ib;
	}
};
Console.getBrowserFormat = function(flag) {
	if(flag.charAt(0) == "#") {
		return "color: " + flag;
	}
	if(HxOverrides.substr(flag,0,3) == "bg#") {
		return "background-color: " + HxOverrides.substr(flag,2,null);
	}
	if(flag.charAt(0) == "{") {
		return HxOverrides.substr(flag,1,flag.length - 2);
	}
	switch(flag) {
	case "bg_black":
		return "background-color: black";
	case "bg_blue":
		return "background-color: blue";
	case "bg_cyan":
		return "background-color: cyan";
	case "bg_green":
		return "background-color: green";
	case "bg_light_black":
		return "background-color: gray";
	case "bg_light_blue":
		return "background-color: lightBlue";
	case "bg_light_cyan":
		return "background-color: lightCyan";
	case "bg_light_green":
		return "background-color: lightGreen";
	case "bg_light_magenta":
		return "background-color: lightPink";
	case "bg_light_red":
		return "background-color: salmon";
	case "bg_light_white":
		return "background-color: white";
	case "bg_light_yellow":
		return "background-color: lightYellow";
	case "bg_magenta":
		return "background-color: magenta";
	case "bg_red":
		return "background-color: red";
	case "bg_white":
		return "background-color: whiteSmoke";
	case "bg_yellow":
		return "background-color: gold";
	case "black":
		return "color: black";
	case "blink":
		return "text-decoration: blink";
	case "blue":
		return "color: blue";
	case "bold":
		return "font-weight: bold";
	case "cyan":
		return "color: cyan";
	case "dim":
		return "color: gray";
	case "green":
		return "color: green";
	case "hidden":
		return "visibility: hidden; color: white";
	case "invert":
		return "-webkit-filter: invert(100%); filter: invert(100%)";
	case "italic":
		return "font-style: italic";
	case "light_black":
		return "color: gray";
	case "light_blue":
		return "color: lightBlue";
	case "light_cyan":
		return "color: lightCyan";
	case "light_green":
		return "color: lightGreen";
	case "light_magenta":
		return "color: lightPink";
	case "light_red":
		return "color: salmon";
	case "light_white":
		return "color: white";
	case "light_yellow":
		return "color: #ffed88";
	case "magenta":
		return "color: magenta";
	case "red":
		return "color: red";
	case "reset":
		return "";
	case "underline":
		return "text-decoration: underline";
	case "white":
		return "color: whiteSmoke";
	case "yellow":
		return "color: #f5ba00";
	default:
		return "";
	}
};
Console.determineConsoleFormatMode = function() {
	var hasWindowObject = typeof window !== "undefined";
	if(hasWindowObject) {
		return 1;
	}
	var tputColors = Console.exec("tput colors");
	if(tputColors.exit == 0) {
		var tputResult = Std.parseInt(tputColors.stdout);
		if(tputResult != null && tputResult > 2) {
			return 0;
		}
	}
	var _this = Sys.environment();
	var termEnv = __map_reserved["TERM"] != null ? _this.getReserved("TERM") : _this.h["TERM"];
	if(termEnv != null && new EReg("cygwin|xterm|vt100","").match(termEnv)) {
		return 0;
	}
	return 2;
};
Console.exec = function(cmd,args) {
	var p = js_node_ChildProcess.spawnSync(cmd,args != null ? args : [],{ });
	var stdout = p.stdout == null ? "" : p.stdout.toString();
	if(stdout == null) {
		stdout = "";
	}
	return { exit : p.status, stdout : stdout};
};
var _$Console_FormatFlag_$Impl_$ = {};
_$Console_FormatFlag_$Impl_$.__name__ = true;
_$Console_FormatFlag_$Impl_$.fromString = function(str) {
	str = str.toLowerCase();
	if(str.charAt(0) == "#" || HxOverrides.substr(str,0,3) == "bg#") {
		var hIdx = str.indexOf("#");
		var hex = HxOverrides.substr(str,hIdx + 1,null);
		if(hex.length == 3) {
			var a = hex.split("");
			hex = [a[0],a[0],a[1],a[1],a[2],a[2]].join("");
		}
		if(new EReg("[^0-9a-f]","i").match(hex) || hex.length < 6) {
			return "";
		}
		var normalized = str.substring(0,hIdx) + "#" + hex;
		return normalized;
	}
	switch(str) {
	case "!":
		return "invert";
	case "/":
		return "reset";
	case "b":
		return "bold";
	case "bg_gray":
		return "bg_light_black";
	case "gray":
		return "light_black";
	case "i":
		return "italic";
	case "u":
		return "underline";
	default:
		return str;
	}
};
var Main = function() { };
Main.__name__ = true;
Main.main = function() {
	Console.errorPrefix = "<b><red>></b> ";
	Console.warnPrefix = "<b><yellow>></b> ";
	var msdfBinaryName = Sys.systemName() == "Windows" ? "msdfgen.exe" : "msdfgen";
	var msdfSearchDirectories = [".","msdfgen","prebuilt"];
	var programDirectory = haxe_io_Path.directory(__filename);
	var _g = 0;
	while(_g < msdfSearchDirectories.length) {
		var dir = msdfSearchDirectories[_g];
		++_g;
		var path = haxe_io_Path.join([programDirectory,dir,msdfBinaryName]);
		if(sys_FileSystem.exists(path) && !sys_FileSystem.isDirectory(path)) {
			Main.msdfgenPath = path;
			break;
		}
	}
	var showHelp = false;
	var argHandler_getDoc = function() {
		return "_ <path>                          : Path of TrueType font file (.ttf)\n['--charset'] <path>              : Path of file containing character set\n['--charlist'] <characters>       : List of characters\n['--output-dir', '-o'] <path>     : Sets the path of the output font file. External resources will be saved in the same directory\n['--technique'] <name>            : Font rendering technique, one of: msdf, sdf, bitmap\n['--msdfgen'] <path>              : Path of msdfgen executable\n['--size'] <glyphSize>            : Maximum dimension of a glyph in pixels\n['--pxrange'] <range>             : Specifies the width of the range around the shape between the minimum and maximum representable signed distance in pixels\n['--max-texture-size'] <size>     : Sets the maximum dimension of the texture atlas\n['--bounds'] <enabled>            : Enables storing glyph bounding boxes in the font (default false)\n['--binary'] <enabled>            : Saves the font in the binary format (default true)\n['--external-textures'] <enabled> : Store textures externally when saving in the binary format\n['--preserve-tmp']                : Preserves any temporary files generated (default false)\n['--help']                        : Shows this help";
	};
	var argHandler_parse = function(__args) {
		var __index = 0;
		while(__index < __args.length) {
			var _g1 = __args[__index++];
			switch(_g1) {
			case "--binary":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.saveBinary = __args[__index] == "true";
				++__index;
				break;
			case "--bounds":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.storeBounds = __args[__index] == "true";
				++__index;
				break;
			case "--charlist":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.charList = __args[__index].split("");
				++__index;
				break;
			case "--charset":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.charsetPath = __args[__index];
				++__index;
				break;
			case "--external-textures":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.externalTextures = __args[__index] == "true";
				++__index;
				break;
			case "--help":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				showHelp = true;
				__index += 0;
				break;
			case "--max-texture-size":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.maximumTextureSize = Std.parseInt(__args[__index]);
				++__index;
				break;
			case "--msdfgen":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.msdfgenPath = __args[__index];
				++__index;
				break;
			case "--preserve-tmp":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				Main.preserveTmp = true;
				__index += 0;
				break;
			case "--pxrange":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.fieldRange_px = Std.parseInt(__args[__index]);
				++__index;
				break;
			case "--size":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.size_px = Std.parseInt(__args[__index]);
				++__index;
				break;
			case "--technique":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.technique = __args[__index];
				++__index;
				break;
			case "--output-dir":case "-o":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.fontOutputDirectory = __args[__index];
				++__index;
				break;
			default:
				var arg = _g1;
				var path1 = arg;
				if(path1.charAt(0) == "-") {
					if(["-help","-h","-?"].indexOf(path1) != -1) {
						showHelp = true;
					} else {
						throw new js__$Boot_HaxeError("Unrecognized argument <b>\"" + path1 + "\"</b>");
					}
				}
				Main.sourceTtfPaths.push(path1);
			}
		}
	};
	var printUsage = function() {
		Console.printFormatted("<b>Usage:</b> <TrueType font path> [options]\n" + "\n",0);
		Console.print(argHandler_getDoc());
		Console.print("\n",0);
		Console.print("\n",0);
	};
	try {
		argHandler_parse(process.argv.slice(2));
		if(showHelp) {
			printUsage();
			process.exit(0);
			return;
		}
		if(!sys_FileSystem.exists(Main.msdfgenPath)) {
			throw new js__$Boot_HaxeError("msdfgen executable was not found at <b>\"" + Main.msdfgenPath + "\"</b> – ensure it is built");
		}
		if(Main.sourceTtfPaths.length == 0) {
			throw new js__$Boot_HaxeError("Path of source TrueType font file is required");
		}
		var _g2 = 0;
		var _g11 = Main.sourceTtfPaths;
		while(_g2 < _g11.length) {
			var ttfPath = _g11[_g2];
			++_g2;
			if(!sys_FileSystem.exists(ttfPath)) {
				throw new js__$Boot_HaxeError("Font file <b>\"" + ttfPath + "\"</b> does not exist");
			}
		}
		if(Main.charList == null) {
			var tmp;
			if(Main.charsetPath == null) {
				Console.printFormatted(Console.warnPrefix + "No charset supplied, using ASCII charset by default, add --charset {path-to-txt-file} to specify which characters the generated font should" + "\n",1);
				tmp = "\t !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~".split("");
			} else {
				tmp = js_node_Fs.readFileSync(Main.charsetPath,{ encoding : "utf8"}).split("");
			}
			Main.charList = tmp;
		}
		var _g3 = Main.technique;
		if(_g3 != "msdf") {
			throw new js__$Boot_HaxeError("Font technique <b>\"" + Main.technique + "\"</b> is not implemented");
		}
	} catch( e ) {
		Console.printFormatted(Console.errorPrefix + ("" + Std.string((e instanceof js__$Boot_HaxeError) ? e.val : e)) + "\n",2);
		Console.print("\n",0);
		printUsage();
		process.exit(1);
		return;
	}
	var _g4 = 0;
	var _g12 = Main.sourceTtfPaths;
	while(_g4 < _g12.length) {
		var ttfPath1 = _g12[_g4];
		++_g4;
		sys_FileSystem.createDirectory(Main.localTmpDir);
		var font = [opentype_Opentype.loadSync(ttfPath1)];
		var fontHeight = [font[0].ascender - font[0].descender];
		var fontFileName = haxe_io_Path.withoutDirectory(haxe_io_Path.withoutExtension(ttfPath1));
		var glyphList = Main.charList.filter((function(font1) {
			return function(c) {
				var g = font1[0].charToGlyph(c);
				if(font1[0].hasChar(c)) {
					if(g.xMin != null) {
						return g.name != ".notdef";
					} else {
						return false;
					}
				} else {
					return false;
				}
			};
		})(font));
		var normalizeFUnits = (function(fontHeight1) {
			return function(fUnit) {
				return fUnit / fontHeight1[0];
			};
		})(fontHeight);
		Console.printFormatted(Console.logPrefix + ("" + Std.string("Generating glyphs for <b>\"" + ttfPath1 + "\"</b>")) + "\n",0);
		var imagePath = (function() {
			return function(charCode) {
				return "" + Main.localTmpDir + "/" + charCode + "-" + Main.size_px + ".bmp";
			};
		})();
		var metricsPath = (function() {
			return function(charCode1) {
				return "" + Main.localTmpDir + "/" + charCode1 + "-" + Main.size_px + "-metrics.txt";
			};
		})();
		var _g21 = 0;
		var _g31 = Main.charList;
		while(_g21 < _g31.length) {
			var char = _g31[_g21];
			++_g21;
			var charCode2 = HxOverrides.cca(char,0);
			var cmd = "" + Main.msdfgenPath + " msdf -autoframe -font " + ttfPath1 + " " + charCode2 + " -size " + Main.size_px + " " + Main.size_px + " -printmetrics -pxrange " + Main.fieldRange_px + " -o \"" + imagePath(charCode2) + "\"> \"" + metricsPath(charCode2) + "\"";
			var e1 = js_node_ChildProcess.spawnSync(cmd,{ shell : true, stdio : "inherit"}).status;
			if(e1 != 0) {
				Console.printFormatted(Console.errorPrefix + ("" + Std.string("" + Main.msdfgenPath + " exited with code " + e1)) + "\n",2);
				process.exit(e1);
				return;
			}
		}
		Console.printFormatted(Console.logPrefix + "Reading glyph metrics" + "\n",0);
		var this1 = { };
		var atlasCharacters = this1;
		var _g22 = 0;
		var _g32 = Main.charList;
		while(_g22 < _g32.length) {
			var char1 = _g32[_g22];
			++_g22;
			atlasCharacters[char1] = { advance : 1, glyph : { atlasScale : 64.0, atlasRect : null, offset : { x : 0, y : 0}}};
		}
		var this2 = { };
		var glyphBounds = this2;
		var _g23 = 0;
		var _g33 = Main.charList;
		while(_g23 < _g33.length) {
			var char2 = _g33[_g23];
			++_g23;
			var charCode3 = HxOverrides.cca(char2,0);
			var metricsFileContent = js_node_Fs.readFileSync(metricsPath(charCode3),{ encoding : "utf8"});
			var atlasCharacter = atlasCharacters[char2];
			var varPattern = new EReg("^\\s*(\\w+)\\s*=([^\n]+)","");
			var str = metricsFileContent;
			while(varPattern.match(str)) {
				var name = varPattern.matched(1);
				var value = varPattern.matched(2).split(",").map((function() {
					return function(f) {
						return parseFloat(f);
					};
				})());
				switch(name) {
				case "advance":
					atlasCharacter.advance = normalizeFUnits(value[0] * 64.0);
					break;
				case "bounds":
					glyphBounds[char2] = { l : normalizeFUnits(value[0] * 64.0), b : normalizeFUnits(value[1] * 64.0), r : normalizeFUnits(value[2] * 64.0), t : normalizeFUnits(value[3] * 64.0)};
					break;
				case "scale":
					var tmp1 = normalizeFUnits(1 / value[0] * 64.0);
					atlasCharacter.glyph.atlasScale = 1 / tmp1;
					break;
				case "translate":
					var tmp2 = normalizeFUnits(value[0] * 64.0);
					var tmp3 = normalizeFUnits(value[1] * 64.0);
					atlasCharacter.glyph.offset = { x : tmp2, y : tmp3};
					break;
				}
				str = varPattern.matchedRight();
			}
		}
		Console.printFormatted(Console.logPrefix + "Packing glyphs into texture" + "\n",0);
		var _g24 = [];
		var _g34 = 0;
		while(_g34 < glyphList.length) {
			var _ = glyphList[_g34];
			++_g34;
			_g24.push({ w : Main.size_px, h : Main.size_px});
		}
		var blocks = _g24;
		var atlasW = Main.ceilPot(Main.size_px);
		var atlasH = Main.ceilPot(Main.size_px);
		var mode = -1;
		var fitSucceeded = false;
		while(atlasW <= Main.maximumTextureSize && atlasH <= Main.maximumTextureSize) {
			var nodes = BinPacker.fit(blocks,atlasW,atlasH);
			if(nodes.indexOf(null) != -1) {
				if(mode == -1) {
					atlasW *= 2;
				} else {
					atlasH *= 2;
				}
				mode *= -1;
			} else {
				var _g41 = 0;
				var _g35 = glyphList.length;
				while(_g41 < _g35) {
					var i = _g41++;
					var char3 = glyphList[i];
					var block = blocks[i];
					var node = nodes[i];
					atlasCharacters[char3].glyph.atlasRect = { x : Math.floor(node.x), y : Math.floor(node.y), w : block.w, h : block.h};
				}
				fitSucceeded = true;
				break;
			}
		}
		if(!fitSucceeded) {
			Console.printFormatted(Console.errorPrefix + ("" + Std.string("Could not fit glyphs into " + Main.maximumTextureSize + "x" + Main.maximumTextureSize + " texture - try a smaller character set or reduced glyph size (multi-atlas is not implemented)")) + "\n",2);
			process.exit(1);
		}
		var _g36 = 0;
		var _g42 = Main.charList;
		while(_g36 < _g42.length) {
			var char4 = _g42[_g36];
			++_g36;
			var hasGlyph = glyphList.indexOf(char4) != -1;
			if(!hasGlyph) {
				Reflect.deleteField(atlasCharacters[char4],"glyph");
			}
		}
		var channels = 3;
		var bytesPerChannel = 1;
		var mapRgbBytes = haxe_io_Bytes.ofData(new ArrayBuffer(channels * bytesPerChannel * atlasW * atlasH));
		var _g37 = 0;
		while(_g37 < glyphList.length) {
			var char5 = glyphList[_g37];
			++_g37;
			var charCode4 = HxOverrides.cca(char5,0);
			var input = new sys_io_FileInput(js_node_Fs.openSync(imagePath(charCode4),"r"));
			var bmpData = new format_bmp_Reader(input).read();
			var glyphHeader = bmpData.header;
			var glyphBGRA = format_bmp_Tools._extract32(bmpData,format_bmp_Tools.BGRA_MAP,255);
			var rect = atlasCharacters[char5].glyph.atlasRect;
			var _g5 = 0;
			var _g43 = glyphHeader.width;
			while(_g5 < _g43) {
				var x = _g5++;
				var _g7 = 0;
				var _g6 = glyphHeader.height;
				while(_g7 < _g6) {
					var y = _g7++;
					var i1 = (y * glyphHeader.width + x) * 4;
					var b = glyphBGRA.b[i1];
					var g1 = glyphBGRA.b[i1 + 1];
					var r = glyphBGRA.b[i1 + 2];
					var mx = x + (rect.x | 0);
					var my = y + (rect.y | 0);
					var mi = (my * atlasW + mx) * 3;
					mapRgbBytes.b[mi] = b & 255;
					mapRgbBytes.b[mi + 1] = g1 & 255;
					mapRgbBytes.b[mi + 2] = r & 255;
				}
			}
		}
		if(!Main.preserveTmp) {
			Console.printFormatted(Console.logPrefix + "Deleting glyph cache" + "\n",0);
			var tmpFiles = js_node_Fs.readdirSync(Main.localTmpDir);
			var _g38 = 0;
			while(_g38 < tmpFiles.length) {
				var name1 = tmpFiles[_g38];
				++_g38;
				try {
					js_node_Fs.unlinkSync(haxe_io_Path.join([Main.localTmpDir,name1]));
				} catch( e2 ) {
					var e3 = (e2 instanceof js__$Boot_HaxeError) ? e2.val : e2;
				}
			}
			js_node_Fs.rmdirSync(Main.localTmpDir);
		}
		var textureFileName = "" + fontFileName + "-0.png";
		var textureFilePath = haxe_io_Path.join([Main.fontOutputDirectory,textureFileName]);
		var pngData = format_png_Tools.buildRGB(atlasW,atlasH,mapRgbBytes,9);
		var pngOutput = new haxe_io_BytesOutput();
		new format_png_Writer(pngOutput).write(pngData);
		var pngBytes = pngOutput.getBytes();
		var this3 = { };
		var kerningMap = this3;
		var _g39 = 0;
		var _g44 = Main.charList;
		while(_g39 < _g44.length) {
			var first = _g44[_g39];
			++_g39;
			var _g51 = 0;
			var _g61 = Main.charList;
			while(_g51 < _g61.length) {
				var second = _g61[_g51];
				++_g51;
				var kerningAmount_fu = font[0].charToGlyph(first);
				var kerningAmount_fu1 = font[0].charToGlyph(second);
				var kerningAmount_fu2 = font[0].getKerningValue(kerningAmount_fu,kerningAmount_fu1);
				if(kerningAmount_fu2 != null && kerningAmount_fu2 != 0) {
					kerningMap[first + second] = normalizeFUnits(kerningAmount_fu2);
				}
			}
		}
		var processFontNameField = (function() {
			return function(field) {
				if(field == null) {
					return null;
				}
				if(field.en == null) {
					return null;
				}
				return StringTools.trim(field.en);
			};
		})();
		var jsonFont = Main.textureAtlasFontVersion;
		var jsonFont1 = font[0].ascender / fontHeight[0];
		var jsonFont2 = font[0].descender / fontHeight[0];
		var jsonFont3 = font[0].tables.os2.sTypoAscender / fontHeight[0];
		var jsonFont4 = font[0].tables.os2.sTypoDescender / fontHeight[0];
		var jsonFont5 = font[0].tables.os2.sxHeight / fontHeight[0];
		var jsonFont6 = processFontNameField(font[0].names.fontFamily);
		var jsonFont7 = processFontNameField(font[0].names.fontSubfamily);
		var jsonFont8 = processFontNameField(font[0].names.version);
		var jsonFont9 = processFontNameField(font[0].names.postScriptName);
		var jsonFont10 = processFontNameField(font[0].names.copyright);
		var jsonFont11 = processFontNameField(font[0].names.trademark);
		var jsonFont12 = processFontNameField(font[0].names.manufacturer);
		var jsonFont13 = processFontNameField(font[0].names.manufacturerURL);
		var jsonFont14 = processFontNameField(font[0].names.designerURL);
		var jsonFont15 = processFontNameField(font[0].names.license);
		var jsonFont16 = processFontNameField(font[0].names.licenseURL);
		var jsonFont17 = { format : "TextureAtlasFontJson", version : jsonFont, technique : "msdf", characters : atlasCharacters, kerning : kerningMap, textures : [[{ localPath : textureFileName}]], textureSize : { w : atlasW, h : atlasH}, ascender : jsonFont1, descender : jsonFont2, typoAscender : jsonFont3, typoDescender : jsonFont4, lowercaseHeight : jsonFont5, metadata : { family : jsonFont6, subfamily : jsonFont7, version : jsonFont8, postScriptName : jsonFont9, copyright : jsonFont10, trademark : jsonFont11, manufacturer : jsonFont12, manufacturerURL : jsonFont13, designerURL : jsonFont14, license : jsonFont15, licenseURL : jsonFont16, height_funits : fontHeight[0], funitsPerEm : font[0].unitsPerEm}, glyphBounds : Main.storeBounds ? glyphBounds : null, fieldRange_px : Main.fieldRange_px};
		if(Main.fontOutputDirectory != "") {
			sys_FileSystem.createDirectory(Main.fontOutputDirectory);
		}
		if(!Main.saveBinary) {
			var fontJsonOutputPath = haxe_io_Path.join([Main.fontOutputDirectory,fontFileName + ".json"]);
			js_node_Fs.writeFileSync(fontJsonOutputPath,JSON.stringify(jsonFont17,null,"\t"));
			Console.printFormatted(Console.successPrefix + ("" + Std.string("Saved <b>\"" + fontJsonOutputPath + "\"</b>")) + "\n",0);
			var data = pngBytes.b;
			js_node_Fs.writeFileSync(textureFilePath,new js_node_buffer_Buffer(data.buffer,data.byteOffset,pngBytes.length));
			Console.printFormatted(Console.successPrefix + ("" + Std.string("Saved <b>\"" + textureFilePath + "\"</b> (" + atlasW + "x" + atlasH + ", " + glyphList.length + " glyphs)")) + "\n",0);
		} else {
			var header = { format : "TextureAtlasFontBinary", version : Main.textureAtlasFontVersion, technique : jsonFont17.technique, ascender : jsonFont17.ascender, descender : jsonFont17.descender, typoAscender : jsonFont17.typoAscender, typoDescender : jsonFont17.typoDescender, lowercaseHeight : jsonFont17.lowercaseHeight, metadata : jsonFont17.metadata, fieldRange_px : jsonFont17.fieldRange_px, textureSize : jsonFont17.textureSize, charList : Main.charList, kerningPairs : Reflect.fields(jsonFont17.kerning), characters : null, kerning : null, glyphBounds : null, textures : null};
			var payload = new haxe_io_BytesOutput();
			var payloadPos = 0;
			var characterDataBytes = new haxe_io_BytesOutput();
			var characterDataLength_bytes = 24;
			var tmp4 = Main.charList.length * characterDataLength_bytes;
			var _g310 = 0;
			var _g45 = Main.charList;
			while(_g310 < _g45.length) {
				var character = _g45[_g310];
				++_g310;
				var characterData = atlasCharacters[character];
				characterDataBytes.writeFloat(characterData.advance);
				var glyph = characterData.glyph != null ? characterData.glyph : { atlasRect : { x : 0, y : 0, w : 0, h : 0}, atlasScale : 0.0, offset : { x : 0.0, y : 0.0}};
				characterDataBytes.writeUInt16(glyph.atlasRect.x);
				characterDataBytes.writeUInt16(glyph.atlasRect.y);
				characterDataBytes.writeUInt16(glyph.atlasRect.w);
				characterDataBytes.writeUInt16(glyph.atlasRect.h);
				characterDataBytes.writeFloat(glyph.atlasScale);
				characterDataBytes.writeFloat(glyph.offset.x);
				characterDataBytes.writeFloat(glyph.offset.y);
			}
			payload.write(characterDataBytes.getBytes());
			header.characters = { start : payloadPos, length : characterDataBytes.b.pos};
			payloadPos = payload.b.pos;
			var kerningBytes = new haxe_io_BytesOutput();
			var kerningDataLength_bytes = 4;
			var tmp5 = kerningDataLength_bytes * Reflect.fields(jsonFont17.kerning).length;
			var _g311 = 0;
			var _g46 = Reflect.fields(jsonFont17.kerning);
			while(_g311 < _g46.length) {
				var k = _g46[_g311];
				++_g311;
				kerningBytes.writeFloat(jsonFont17.kerning[k]);
			}
			payload.write(kerningBytes.getBytes());
			header.kerning = { start : payloadPos, length : kerningBytes.b.pos};
			payloadPos = payload.b.pos;
			if(Main.storeBounds) {
				var boundsBytes = new haxe_io_BytesOutput();
				var boundsDataLength_bytes = 16;
				var tmp6 = boundsDataLength_bytes * Reflect.fields(glyphBounds).length;
				var _g312 = 0;
				var _g47 = Main.charList;
				while(_g312 < _g47.length) {
					var character1 = _g47[_g312];
					++_g312;
					var bounds = glyphBounds[character1];
					if(bounds == null) {
						bounds = { l : 0, r : 0, t : 0, b : 0};
					}
					boundsBytes.writeFloat(bounds.t);
					boundsBytes.writeFloat(bounds.r);
					boundsBytes.writeFloat(bounds.b);
					boundsBytes.writeFloat(bounds.l);
				}
				header.glyphBounds = { start : payloadPos, length : boundsBytes.b.pos};
				payloadPos = payload.b.pos;
			}
			if(Main.externalTextures) {
				var data1 = pngBytes.b;
				js_node_Fs.writeFileSync(textureFilePath,new js_node_buffer_Buffer(data1.buffer,data1.byteOffset,pngBytes.length));
				Console.printFormatted(Console.successPrefix + ("" + Std.string("Saved <b>\"" + textureFilePath + "\"</b> (" + atlasW + "x" + atlasH + ", " + glyphList.length + " glyphs)")) + "\n",0);
				header.textures = [[{ localPath : textureFileName}]];
			} else {
				payload.write(pngBytes);
				header.textures = [[{ payloadBytes : { start : payloadPos, length : pngBytes.length}}]];
				payloadPos = payload.b.pos;
			}
			var binaryFontOutput = new haxe_io_BytesOutput();
			binaryFontOutput.writeString(JSON.stringify(header));
			binaryFontOutput.writeByte(0);
			binaryFontOutput.write(payload.getBytes());
			var fontBinOutputPath = haxe_io_Path.join([Main.fontOutputDirectory,fontFileName + "." + Main.technique + ".bin"]);
			var bytes = binaryFontOutput.getBytes();
			var data2 = bytes.b;
			js_node_Fs.writeFileSync(fontBinOutputPath,new js_node_buffer_Buffer(data2.buffer,data2.byteOffset,bytes.length));
			Console.printFormatted(Console.successPrefix + ("" + Std.string("Saved <b>\"" + fontBinOutputPath + "\"</b>")) + "\n",0);
		}
	}
};
Main.ceilPot = function(x) {
	return Math.pow(2,Math.ceil(Math.log(x) / Math.log(2))) | 0;
};
Math.__name__ = true;
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,set_bigEndian: function(b) {
		this.bigEndian = b;
		return b;
	}
	,write: function(s) {
		var l = s.length;
		var p = 0;
		while(l > 0) {
			var k = this.writeBytes(s,p,l);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			p += k;
			l -= k;
		}
	}
	,writeFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	,writeFloat: function(x) {
		this.writeInt32(haxe_io_FPHelper.floatToI32(x));
	}
	,writeUInt16: function(x) {
		if(x < 0 || x >= 65536) {
			throw new js__$Boot_HaxeError(haxe_io_Error.Overflow);
		}
		if(this.bigEndian) {
			this.writeByte(x >> 8);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8);
		}
	}
	,writeInt32: function(x) {
		if(this.bigEndian) {
			this.writeByte(x >>> 24);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >>> 24);
		}
	}
	,writeString: function(s) {
		var b = haxe_io_Bytes.ofString(s);
		this.writeFullBytes(b,0,b.length);
	}
};
var _$Sys_FileOutput = function(fd) {
	this.fd = fd;
};
_$Sys_FileOutput.__name__ = true;
_$Sys_FileOutput.__super__ = haxe_io_Output;
_$Sys_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		js_node_Fs.writeSync(this.fd,String.fromCharCode(c));
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		return js_node_Fs.writeSync(this.fd,new js_node_buffer_Buffer(data.buffer,data.byteOffset,s.length),pos,len);
	}
	,writeString: function(s) {
		js_node_Fs.writeSync(this.fd,s);
	}
});
var haxe_io_Input = function() { };
haxe_io_Input.__name__ = true;
haxe_io_Input.prototype = {
	readByte: function() {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,readBytes: function(s,pos,len) {
		var k = len;
		var b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( eof ) {
			if(!((eof instanceof js__$Boot_HaxeError) ? eof.val : eof instanceof haxe_io_Eof)) {
				throw eof;
			}
		}
		return len - k;
	}
	,readFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.readBytes(s,pos,len);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			pos += k;
			len -= k;
		}
	}
	,readInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var n = this.bigEndian ? ch2 | ch1 << 8 : ch1 | ch2 << 8;
		if((n & 32768) != 0) {
			return n - 65536;
		}
		return n;
	}
	,readInt32: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var ch3 = this.readByte();
		var ch4 = this.readByte();
		if(this.bigEndian) {
			return ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16 | ch4 << 24;
		}
	}
};
var format_bmp_Reader = function(i) {
	this.input = i;
};
format_bmp_Reader.__name__ = true;
format_bmp_Reader.prototype = {
	read: function() {
		if(this.input.readByte() != 66) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		if(this.input.readByte() != 77) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var fileSize = this.input.readInt32();
		this.input.readInt32();
		var offset = this.input.readInt32();
		this.input.readInt32();
		var width = this.input.readInt32();
		var height = this.input.readInt32();
		this.input.readInt16();
		var bits = this.input.readInt16();
		var compression = this.input.readInt32();
		var dataLength = this.input.readInt32();
		this.input.readInt32();
		this.input.readInt32();
		this.input.readInt32();
		this.input.readInt32();
		if(compression == 0 && dataLength == 0) {
			dataLength = fileSize - offset;
		}
		if(bits != 24) {
			throw new js__$Boot_HaxeError("" + bits + "bpp bitmaps not implemented.");
		}
		var p = new haxe_io_Bytes(new ArrayBuffer(dataLength));
		var topToBottom = false;
		if(height < 0) {
			topToBottom = true;
			height = -height;
		}
		this.input.readFullBytes(p,0,dataLength);
		return { header : { width : width, height : height, paddedStride : (width * bits + 31 & -32) >> 3, topToBottom : topToBottom, bpp : bits, dataLength : dataLength}, pixels : p};
	}
};
var format_bmp_Tools = function() { };
format_bmp_Tools.__name__ = true;
format_bmp_Tools._extract32 = function(bmp,channelMap,alpha) {
	if(alpha == null) {
		alpha = 255;
	}
	var srcBytes = bmp.pixels;
	var dstLen = bmp.header.width * bmp.header.height * 4;
	var dstBytes = new haxe_io_Bytes(new ArrayBuffer(dstLen));
	var srcStride = bmp.header.width * 3;
	var srcPaddedStride = bmp.header.paddedStride;
	var yDir = -1;
	var dstPos = 0;
	var srcPos = bmp.header.dataLength - srcPaddedStride;
	if(bmp.header.topToBottom) {
		yDir = 1;
		srcPos = 0;
	}
	while(dstPos < dstLen) {
		var i = srcPos;
		while(i < srcPos + srcStride) {
			var b = srcBytes.b[i];
			var g = srcBytes.b[i + 1];
			var r = srcBytes.b[i + 2];
			dstBytes.b[dstPos + channelMap[0]] = alpha & 255;
			dstBytes.b[dstPos + channelMap[1]] = r & 255;
			dstBytes.b[dstPos + channelMap[2]] = g & 255;
			dstBytes.b[dstPos + channelMap[3]] = b & 255;
			i += 3;
			dstPos += 4;
		}
		srcPos += yDir * srcPaddedStride;
	}
	return dstBytes;
};
var format_png_Color = $hxEnums["format.png.Color"] = { __ename__ : true, __constructs__ : ["ColGrey","ColTrue","ColIndexed"]
	,ColGrey: ($_=function(alpha) { return {_hx_index:0,alpha:alpha,__enum__:"format.png.Color",toString:$estr}; },$_.__params__ = ["alpha"],$_)
	,ColTrue: ($_=function(alpha) { return {_hx_index:1,alpha:alpha,__enum__:"format.png.Color",toString:$estr}; },$_.__params__ = ["alpha"],$_)
	,ColIndexed: {_hx_index:2,__enum__:"format.png.Color",toString:$estr}
};
var format_png_Chunk = $hxEnums["format.png.Chunk"] = { __ename__ : true, __constructs__ : ["CEnd","CHeader","CData","CPalette","CUnknown"]
	,CEnd: {_hx_index:0,__enum__:"format.png.Chunk",toString:$estr}
	,CHeader: ($_=function(h) { return {_hx_index:1,h:h,__enum__:"format.png.Chunk",toString:$estr}; },$_.__params__ = ["h"],$_)
	,CData: ($_=function(b) { return {_hx_index:2,b:b,__enum__:"format.png.Chunk",toString:$estr}; },$_.__params__ = ["b"],$_)
	,CPalette: ($_=function(b) { return {_hx_index:3,b:b,__enum__:"format.png.Chunk",toString:$estr}; },$_.__params__ = ["b"],$_)
	,CUnknown: ($_=function(id,data) { return {_hx_index:4,id:id,data:data,__enum__:"format.png.Chunk",toString:$estr}; },$_.__params__ = ["id","data"],$_)
};
var format_png_Tools = function() { };
format_png_Tools.__name__ = true;
format_png_Tools.buildRGB = function(width,height,data,level) {
	if(level == null) {
		level = 9;
	}
	var rgb = new haxe_io_Bytes(new ArrayBuffer(width * height * 3 + height));
	var w = 0;
	var r = 0;
	var _g1 = 0;
	while(_g1 < height) {
		++_g1;
		rgb.b[w++] = 0;
		var _g3 = 0;
		while(_g3 < width) {
			++_g3;
			rgb.b[w++] = data.b[r + 2] & 255;
			rgb.b[w++] = data.b[r + 1] & 255;
			rgb.b[w++] = data.b[r] & 255;
			r += 3;
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColTrue(false), interlaced : false}));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
var format_png_Writer = function(o) {
	this.o = o;
	o.set_bigEndian(true);
};
format_png_Writer.__name__ = true;
format_png_Writer.prototype = {
	write: function(png) {
		this.o.writeByte(137);
		this.o.writeByte(80);
		this.o.writeByte(78);
		this.o.writeByte(71);
		this.o.writeByte(13);
		this.o.writeByte(10);
		this.o.writeByte(26);
		this.o.writeByte(10);
		var _g_head = png.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			switch(val._hx_index) {
			case 0:
				this.writeChunk("IEND",new haxe_io_Bytes(new ArrayBuffer(0)));
				break;
			case 1:
				var h = val.h;
				var b = new haxe_io_BytesOutput();
				b.set_bigEndian(true);
				b.writeInt32(h.width);
				b.writeInt32(h.height);
				b.writeByte(h.colbits);
				var _g = h.color;
				var tmp;
				switch(_g._hx_index) {
				case 0:
					tmp = _g.alpha ? 4 : 0;
					break;
				case 1:
					tmp = _g.alpha ? 6 : 2;
					break;
				case 2:
					tmp = 3;
					break;
				}
				b.writeByte(tmp);
				b.writeByte(0);
				b.writeByte(0);
				b.writeByte(h.interlaced ? 1 : 0);
				this.writeChunk("IHDR",b.getBytes());
				break;
			case 2:
				this.writeChunk("IDAT",val.b);
				break;
			case 3:
				this.writeChunk("PLTE",val.b);
				break;
			case 4:
				this.writeChunk(val.id,val.data);
				break;
			}
		}
	}
	,writeChunk: function(id,data) {
		this.o.writeInt32(data.length);
		this.o.writeString(id);
		this.o.write(data);
		var crc = new haxe_crypto_Crc32();
		var _g = 0;
		while(_g < 4) crc.byte(HxOverrides.cca(id,_g++));
		crc.update(data,0,data.length);
		this.o.writeInt32(crc.get());
	}
};
var format_tools_Deflate = function() { };
format_tools_Deflate.__name__ = true;
format_tools_Deflate.run = function(b,level) {
	if(level == null) {
		level = 9;
	}
	return haxe_zip_Compress.run(b,level);
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_crypto_Crc32 = function() {
	this.crc = -1;
};
haxe_crypto_Crc32.__name__ = true;
haxe_crypto_Crc32.prototype = {
	byte: function(b) {
		var tmp = (this.crc ^ b) & 255;
		var _g = 0;
		while(_g < 8) {
			++_g;
			if((tmp & 1) == 1) {
				tmp = tmp >>> 1 ^ -306674912;
			} else {
				tmp >>>= 1;
			}
		}
		this.crc = this.crc >>> 8 ^ tmp;
	}
	,update: function(b,pos,len) {
		var b1 = b.b.bufferValue;
		var _g1 = pos;
		var _g = pos + len;
		while(_g1 < _g) {
			var tmp = (this.crc ^ b1.bytes[_g1++]) & 255;
			var _g2 = 0;
			while(_g2 < 8) {
				++_g2;
				if((tmp & 1) == 1) {
					tmp = tmp >>> 1 ^ -306674912;
				} else {
					tmp >>>= 1;
				}
			}
			this.crc = this.crc >>> 8 ^ tmp;
		}
	}
	,get: function() {
		return this.crc ^ -1;
	}
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
var haxe_ds_List = function() {
	this.length = 0;
};
haxe_ds_List.__name__ = true;
haxe_ds_List.prototype = {
	add: function(item) {
		var x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,iterator: function() {
		return new haxe_ds__$List_ListIterator(this.h);
	}
};
var haxe_ds__$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
haxe_ds__$List_ListNode.__name__ = true;
var haxe_ds__$List_ListIterator = function(head) {
	this.head = head;
};
haxe_ds__$List_ListIterator.__name__ = true;
haxe_ds__$List_ListIterator.prototype = {
	hasNext: function() {
		return this.head != null;
	}
	,next: function() {
		var val = this.head.item;
		this.head = this.head.next;
		return val;
	}
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.alloc = function(length) {
	return new haxe_io_Bytes(new ArrayBuffer(length));
};
haxe_io_Bytes.ofString = function(s) {
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new haxe_io_Bytes(b);
};
haxe_io_Bytes.fastGet = function(b,pos) {
	return b.bytes[pos];
};
haxe_io_Bytes.prototype = {
	blit: function(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	,fill: function(pos,len,value) {
		var _g1 = 0;
		while(_g1 < len) {
			++_g1;
			this.b[pos++] = value & 255;
		}
	}
};
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
haxe_io_BytesBuffer.__name__ = true;
haxe_io_BytesBuffer.prototype = {
	addByte: function(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	,addBytes: function(src,pos,len) {
		if(pos < 0 || len < 0 || pos + len > src.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(this.pos + len > this.size) {
			this.grow(len);
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset + pos,len);
		this.u8.set(sub,this.pos);
		this.pos += len;
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
};
var haxe_io_BytesOutput = function() {
	this.b = new haxe_io_BytesBuffer();
};
haxe_io_BytesOutput.__name__ = true;
haxe_io_BytesOutput.__super__ = haxe_io_Output;
haxe_io_BytesOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		this.b.addByte(c);
	}
	,writeBytes: function(buf,pos,len) {
		this.b.addBytes(buf,pos,len);
		return len;
	}
	,getBytes: function() {
		return this.b.getBytes();
	}
});
var haxe_io_Eof = function() {
};
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var haxe_io_FPHelper = function() { };
haxe_io_FPHelper.__name__ = true;
haxe_io_FPHelper.floatToI32 = function(f) {
	haxe_io_FPHelper.helper.setFloat32(0,f,true);
	return haxe_io_FPHelper.helper.getInt32(0,true);
};
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
haxe_io_Path.__name__ = true;
haxe_io_Path.withoutExtension = function(path) {
	var s = new haxe_io_Path(path);
	s.ext = null;
	return s.toString();
};
haxe_io_Path.withoutDirectory = function(path) {
	var s = new haxe_io_Path(path);
	s.dir = null;
	return s.toString();
};
haxe_io_Path.directory = function(path) {
	var s = new haxe_io_Path(path);
	if(s.dir == null) {
		return "";
	}
	return s.dir;
};
haxe_io_Path.join = function(paths) {
	var paths1 = paths.filter(function(s) {
		if(s != null) {
			return s != "";
		} else {
			return false;
		}
	});
	if(paths1.length == 0) {
		return "";
	}
	var path = paths1[0];
	var _g1 = 1;
	var _g = paths1.length;
	while(_g1 < _g) {
		path = haxe_io_Path.addTrailingSlash(path);
		path += paths1[_g1++];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	path = path.split("\\").join("/");
	if(path == "/") {
		return "/";
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split("/");
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join("/");
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g11 = 0;
	var _g2 = tmp.length;
	while(_g11 < _g2) {
		var _g21 = tmp.charCodeAt(_g11++);
		switch(_g21) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCharCode(_g21);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCharCode(_g21);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
haxe_io_Path.prototype = {
	toString: function() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
};
var haxe_io__$UInt16Array_UInt16Array_$Impl_$ = {};
haxe_io__$UInt16Array_UInt16Array_$Impl_$.__name__ = true;
haxe_io__$UInt16Array_UInt16Array_$Impl_$.fromArray = function(a,pos,length) {
	if(pos == null) {
		pos = 0;
	}
	if(length == null) {
		length = a.length - pos;
	}
	if(pos < 0 || length < 0 || pos + length > a.length) {
		throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
	}
	if(pos == 0 && length == a.length) {
		return new Uint16Array(a);
	}
	var i = new Uint16Array(a.length);
	var _g1 = 0;
	var _g = length;
	while(_g1 < _g) {
		var idx = _g1++;
		i[idx] = a[idx + pos] & 65535;
	}
	return i;
};
var haxe_io__$UInt8Array_UInt8Array_$Impl_$ = {};
haxe_io__$UInt8Array_UInt8Array_$Impl_$.__name__ = true;
haxe_io__$UInt8Array_UInt8Array_$Impl_$.fromBytes = function(bytes,bytePos,length) {
	if(bytePos == null) {
		bytePos = 0;
	}
	if(length == null) {
		length = bytes.length - bytePos;
	}
	return new Uint8Array(bytes.b.bufferValue,bytePos,length);
};
var haxe_zip_Compress = function() { };
haxe_zip_Compress.__name__ = true;
haxe_zip_Compress.run = function(s,level) {
	return haxe_io_Bytes.ofData(pako_Pako.deflate(haxe_io__$UInt8Array_UInt8Array_$Impl_$.fromBytes(s),{ level : level}).buffer);
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s += "\t";
				var tmp = n + "(";
				var _g = [];
				var _g1 = 0;
				var _g2 = con.__params__;
				while(_g1 < _g2.length) {
					var p = _g2[_g1];
					++_g1;
					_g.push(js_Boot.__string_rec(o[p],s));
				}
				return tmp + _g.join(",") + ")";
			} else {
				return n;
			}
		}
		if((o instanceof Array)) {
			var l = o.length;
			var i;
			var str = "[";
			s += "\t";
			var _g11 = 0;
			var _g3 = l;
			while(_g11 < _g3) {
				var i1 = _g11++;
				str += (i1 > 0 ? "," : "") + js_Boot.__string_rec(o[i1],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			var e2 = (e1 instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_node_Fs = require("fs");
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
var opentype_Opentype = require("opentype");
var pako_Deflate = function(options) {
	this.result = null;
	this.strm = new pako_zlib_ZStream();
	this.chunks = [];
	this.ended = false;
	this.msg = "";
	this.err = 0;
	this.options = null;
	this.options = { };
	this.options.level = options != null && options.level != null ? options.level : pako_Deflate.DEFAULT_OPTIONS.level;
	this.options.method = options != null && options.method != null ? options.method : pako_Deflate.DEFAULT_OPTIONS.method;
	this.options.chunkSize = options != null && options.chunkSize != null ? options.chunkSize : pako_Deflate.DEFAULT_OPTIONS.chunkSize;
	this.options.windowBits = options != null && options.windowBits != null ? options.windowBits : pako_Deflate.DEFAULT_OPTIONS.windowBits;
	this.options.memLevel = options != null && options.memLevel != null ? options.memLevel : pako_Deflate.DEFAULT_OPTIONS.memLevel;
	this.options.strategy = options != null && options.strategy != null ? options.strategy : pako_Deflate.DEFAULT_OPTIONS.strategy;
	this.options.raw = options != null && options.raw != null ? options.raw : pako_Deflate.DEFAULT_OPTIONS.raw;
	this.options.gzip = options != null && options.gzip != null ? options.gzip : pako_Deflate.DEFAULT_OPTIONS.gzip;
	this.options.header = options != null && options.header != null ? options.header : pako_Deflate.DEFAULT_OPTIONS.header;
	this.options.dictionary = options != null && options.dictionary != null ? options.dictionary : pako_Deflate.DEFAULT_OPTIONS.dictionary;
	if(this.options.raw && this.options.windowBits > 0) {
		this.options.windowBits = -this.options.windowBits;
	} else if(this.options.gzip && this.options.windowBits > 0 && this.options.windowBits < 16) {
		this.options.windowBits += 16;
	}
	this.onData = $bind(this,this._onData);
	this.onEnd = $bind(this,this._onEnd);
	this.strm.avail_out = 0;
	var status = pako_zlib_Deflate.deflateInit2(this.strm,this.options.level,this.options.method,this.options.windowBits,this.options.memLevel,this.options.strategy);
	if(status != 0) {
		throw new js__$Boot_HaxeError(pako_zlib_Messages.get(status));
	}
	if(this.options.header != null) {
		pako_zlib_Deflate.deflateSetHeader(this.strm,this.options.header);
	}
	if(this.options.dictionary != null) {
		status = pako_zlib_Deflate.deflateSetDictionary(this.strm,this.options.dictionary);
	}
	if(status != 0) {
		throw new js__$Boot_HaxeError(pako_zlib_Messages.get(status));
	}
};
pako_Deflate.__name__ = true;
pako_Deflate.prototype = {
	push: function(data,mode) {
		if(mode == null) {
			mode = false;
		}
		var strm = this.strm;
		var chunkSize = this.options.chunkSize;
		var status;
		var _mode;
		if(this.ended) {
			return false;
		}
		if(typeof(mode) == "number" && ((mode | 0) === mode)) {
			_mode = mode;
		} else if(typeof(mode) == "boolean") {
			_mode = mode ? 4 : 0;
		} else {
			throw new js__$Boot_HaxeError("Invalid mode.");
		}
		strm.input = data;
		strm.next_in = 0;
		strm.avail_in = strm.input.length;
		while(true) {
			if(strm.avail_out == 0) {
				strm.output = new Uint8Array(chunkSize);
				strm.next_out = 0;
				strm.avail_out = chunkSize;
			}
			status = pako_zlib_Deflate.deflate(strm,_mode);
			if(status != 1 && status != 0) {
				this.onEnd(status);
				this.ended = true;
				return false;
			}
			if(strm.avail_out == 0 || strm.avail_in == 0 && (_mode == 4 || _mode == 2)) {
				var tmp = this.onData;
				var buf = strm.output;
				var size = strm.next_out;
				if(buf.length != size) {
					buf = buf.subarray(0,size);
				}
				tmp(buf);
			}
			if(!((strm.avail_in > 0 || strm.avail_out == 0) && status != 1)) {
				break;
			}
		}
		if(_mode == 4) {
			status = pako_zlib_Deflate.deflateEnd(this.strm);
			this.onEnd(status);
			this.ended = true;
			return status == 0;
		}
		if(_mode == 2) {
			this.onEnd(0);
			strm.avail_out = 0;
			return true;
		}
		return true;
	}
	,_onData: function(chunk) {
		this.chunks.push(chunk);
	}
	,_onEnd: function(status) {
		if(status == 0) {
			this.result = pako_utils_Common.flattenChunks(this.chunks);
		}
		this.chunks = [];
		this.err = status;
		this.msg = this.strm.msg;
	}
};
var pako_Pako = function() { };
pako_Pako.__name__ = true;
pako_Pako.deflate = function(input,options) {
	var deflator = new pako_Deflate(options);
	deflator.push(input,4);
	if(deflator.err != 0) {
		throw new js__$Boot_HaxeError(deflator.msg != "" ? deflator.msg : pako_zlib_Messages.get(deflator.err));
	}
	return deflator.result;
};
var pako_utils_Common = function() { };
pako_utils_Common.__name__ = true;
pako_utils_Common.flattenChunks = function(chunks) {
	var chunk;
	var len = 0;
	var l = chunks.length;
	var _g1 = 0;
	while(_g1 < l) len += chunks[_g1++].length;
	var result = new Uint8Array(len);
	var pos = 0;
	var _g11 = 0;
	while(_g11 < l) {
		chunk = chunks[_g11++];
		haxe_io_Bytes.ofData(result.buffer).blit(pos,haxe_io_Bytes.ofData(chunk.buffer),0,chunk.length);
		pos += chunk.length;
	}
	return result;
};
var pako_zlib_Adler32 = function() { };
pako_zlib_Adler32.__name__ = true;
pako_zlib_Adler32.adler32 = function(adler,buf,len,pos) {
	var s1 = adler & 65535 | 0;
	var s2 = adler >>> 16 & 65535 | 0;
	var n = 0;
	while(len != 0) {
		n = len > 2000 ? 2000 : len;
		len -= n;
		while(true) {
			s1 = s1 + buf[pos++] | 0;
			s2 = s2 + s1 | 0;
			if(!(--n != 0)) {
				break;
			}
		}
		s1 %= 65521;
		s2 %= 65521;
	}
	return s1 | s2 << 16 | 0;
};
var pako_zlib_CRC32 = function() { };
pako_zlib_CRC32.__name__ = true;
pako_zlib_CRC32.makeTable = function() {
	var c;
	var table = new Array(256);
	var _g = 0;
	while(_g < 256) {
		var n = _g++;
		c = n;
		var _g1 = 0;
		while(_g1 < 8) {
			++_g1;
			if((c & 1) == 1) {
				c = -306674912 ^ c >>> 1;
			} else {
				c >>>= 1;
			}
		}
		table[n] = c;
	}
	return table;
};
pako_zlib_CRC32.crc32 = function(crc,buf,len,pos) {
	var t = pako_zlib_CRC32.crcTable;
	var end = pos + len;
	crc ^= -1;
	var _g1 = pos;
	while(_g1 < end) crc = crc >>> 8 ^ t[(crc ^ buf[_g1++]) & 255];
	return crc ^ -1;
};
var pako_zlib_Trees = function() { };
pako_zlib_Trees.__name__ = true;
pako_zlib_Trees.send_bits = function(s,value,length) {
	if(s.bi_valid > 16 - length) {
		s.bi_buf |= value << s.bi_valid & 65535;
		var w = s.bi_buf;
		s.pending_buf[s.pending++] = w & 255 & 255;
		s.pending_buf[s.pending++] = w >>> 8 & 255 & 255;
		s.bi_buf = value >> 16 - s.bi_valid;
		s.bi_valid += length - 16;
	} else {
		s.bi_buf |= value << s.bi_valid & 65535;
		s.bi_valid += length;
	}
};
pako_zlib_Trees.bi_reverse = function(code,len) {
	var res = 0;
	while(true) {
		res |= code & 1;
		code >>>= 1;
		res <<= 1;
		if(!(--len > 0)) {
			break;
		}
	}
	return res >>> 1;
};
pako_zlib_Trees.bi_flush = function(s) {
	if(s.bi_valid == 16) {
		var w = s.bi_buf;
		s.pending_buf[s.pending++] = w & 255 & 255;
		s.pending_buf[s.pending++] = w >>> 8 & 255 & 255;
		s.bi_buf = 0;
		s.bi_valid = 0;
	} else if(s.bi_valid >= 8) {
		s.pending_buf[s.pending++] = s.bi_buf & 255 & 255;
		s.bi_buf >>= 8;
		s.bi_valid -= 8;
	}
};
pako_zlib_Trees.gen_bitlen = function(s,desc) {
	var tree = desc.dyn_tree;
	var max_code = desc.max_code;
	var stree = desc.stat_desc.static_tree;
	var has_stree = desc.stat_desc.has_stree;
	var extra = desc.stat_desc.extra_bits;
	var base = desc.stat_desc.extra_base;
	var max_length = desc.stat_desc.max_length;
	var n;
	var m;
	var bits;
	var xbits;
	var f;
	var overflow = 0;
	var _g1 = 0;
	while(_g1 < 16) s.bl_count[_g1++] = 0;
	tree[s.heap[s.heap_max] * 2 + 1] = 0;
	var _g = s.heap_max + 1;
	while(_g < 573) {
		n = s.heap[_g++];
		bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
		if(bits > max_length) {
			bits = max_length;
			++overflow;
		}
		tree[n * 2 + 1] = bits & 65535;
		if(n > max_code) {
			continue;
		}
		var _g11 = bits;
		var _g2 = s.bl_count;
		_g2[_g11] = _g2[_g11] + 1 & 65535;
		xbits = 0;
		if(n >= base) {
			xbits = extra[n - base];
		}
		f = tree[n * 2];
		s.opt_len += f * (bits + xbits);
		if(has_stree) {
			s.static_len += f * (stree[n * 2 + 1] + xbits);
		}
	}
	if(overflow == 0) {
		return;
	}
	var h = 573;
	while(true) {
		bits = max_length - 1;
		while(s.bl_count[bits] == 0) --bits;
		var _g3 = bits;
		var _g12 = s.bl_count;
		_g12[_g3] = _g12[_g3] - 1 & 65535;
		var _g4 = bits + 1;
		var _g13 = s.bl_count;
		_g13[_g4] = _g13[_g4] + 2 & 65535;
		var _g14 = s.bl_count;
		_g14[max_length] = _g14[max_length] - 1 & 65535;
		overflow -= 2;
		if(!(overflow > 0)) {
			break;
		}
	}
	bits = max_length;
	while(bits != 0) {
		n = s.bl_count[bits];
		while(n != 0) {
			m = s.heap[--h];
			if(m > max_code) {
				continue;
			}
			if(tree[m * 2 + 1] != bits) {
				s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
				tree[m * 2 + 1] = bits & 65535;
			}
			--n;
		}
		--bits;
	}
};
pako_zlib_Trees.gen_codes = function(tree,max_code,bl_count) {
	var next_code = new Array(16);
	var code = 0;
	var _g1 = 1;
	while(_g1 < 16) {
		var bits = _g1++;
		code = code + bl_count[bits - 1] << 1;
		next_code[bits] = code;
	}
	var _g11 = 0;
	var _g = max_code + 1;
	while(_g11 < _g) {
		var n = _g11++;
		var len = tree[n * 2 + 1];
		if(len == 0) {
			continue;
		}
		tree[n * 2] = pako_zlib_Trees.bi_reverse(next_code[len],len) & 65535;
		next_code[len] = next_code[len] + 1;
	}
};
pako_zlib_Trees.tr_static_init = function() {
	var bl_count = new Uint16Array(16);
	var length = 0;
	var _g1 = 0;
	while(_g1 < 28) {
		var code = _g1++;
		pako_zlib_Trees.base_length[code] = length & 65535;
		var _g3 = 0;
		var _g2 = 1 << pako_zlib_Trees.extra_lbits[code];
		while(_g3 < _g2) {
			++_g3;
			pako_zlib_Trees._length_code[length++] = code & 65535;
		}
	}
	pako_zlib_Trees._length_code[length - 1] = 28;
	var dist = 0;
	var _g = 0;
	while(_g < 16) {
		var code1 = _g++;
		pako_zlib_Trees.base_dist[code1] = dist & 65535;
		var _g21 = 0;
		var _g11 = 1 << pako_zlib_Trees.extra_dbits[code1];
		while(_g21 < _g11) {
			++_g21;
			pako_zlib_Trees._dist_code[dist++] = code1 & 65535;
		}
	}
	dist >>= 7;
	var _g4 = 16;
	while(_g4 < 30) {
		var code2 = _g4++;
		pako_zlib_Trees.base_dist[code2] = dist << 7 & 65535;
		var _g22 = 0;
		var _g12 = 1 << pako_zlib_Trees.extra_dbits[code2] - 7;
		while(_g22 < _g12) {
			++_g22;
			pako_zlib_Trees._dist_code[256 + dist++] = code2 & 65535;
		}
	}
	var _g13 = 0;
	while(_g13 < 16) bl_count[_g13++] = 0;
	var n = 0;
	while(n <= 143) {
		pako_zlib_Trees.static_ltree[n * 2 + 1] = 8;
		++n;
		bl_count[8] = bl_count[8] + 1 & 65535;
	}
	while(n <= 255) {
		pako_zlib_Trees.static_ltree[n * 2 + 1] = 9;
		++n;
		bl_count[9] = bl_count[9] + 1 & 65535;
	}
	while(n <= 279) {
		pako_zlib_Trees.static_ltree[n * 2 + 1] = 7;
		++n;
		bl_count[7] = bl_count[7] + 1 & 65535;
	}
	while(n <= 287) {
		pako_zlib_Trees.static_ltree[n * 2 + 1] = 8;
		++n;
		bl_count[8] = bl_count[8] + 1 & 65535;
	}
	pako_zlib_Trees.gen_codes(pako_zlib_Trees.static_ltree,287,bl_count);
	var _g5 = 0;
	while(_g5 < 30) {
		var n1 = _g5++;
		pako_zlib_Trees.static_dtree[n1 * 2 + 1] = 5;
		pako_zlib_Trees.static_dtree[n1 * 2] = pako_zlib_Trees.bi_reverse(n1,5) & 65535;
	}
	pako_zlib_Trees.static_l_desc = new pako_zlib_StaticTreeDesc(pako_zlib_Trees.static_ltree,pako_zlib_Trees.extra_lbits,257,286,15);
	pako_zlib_Trees.static_d_desc = new pako_zlib_StaticTreeDesc(pako_zlib_Trees.static_dtree,pako_zlib_Trees.extra_dbits,0,30,15);
	pako_zlib_Trees.static_bl_desc = new pako_zlib_StaticTreeDesc(new Uint16Array(0),pako_zlib_Trees.extra_blbits,0,19,7);
};
pako_zlib_Trees.init_block = function(s) {
	var _g = 0;
	while(_g < 286) s.dyn_ltree[_g++ * 2] = 0;
	var _g1 = 0;
	while(_g1 < 30) s.dyn_dtree[_g1++ * 2] = 0;
	var _g2 = 0;
	while(_g2 < 19) s.bl_tree[_g2++ * 2] = 0;
	s.dyn_ltree[512] = 1;
	s.opt_len = s.static_len = 0;
	s.last_lit = s.matches = 0;
};
pako_zlib_Trees.bi_windup = function(s) {
	if(s.bi_valid > 8) {
		var w = s.bi_buf;
		s.pending_buf[s.pending++] = w & 255 & 255;
		s.pending_buf[s.pending++] = w >>> 8 & 255 & 255;
	} else if(s.bi_valid > 0) {
		s.pending_buf[s.pending++] = s.bi_buf & 255;
	}
	s.bi_buf = 0;
	s.bi_valid = 0;
};
pako_zlib_Trees.pqdownheap = function(s,tree,k) {
	var v = s.heap[k];
	var j = k << 1;
	while(j <= s.heap_len) {
		var tmp;
		if(j < s.heap_len) {
			var n = s.heap[j + 1];
			var m = s.heap[j];
			var depth = s.depth;
			var _n2 = n * 2;
			var _m2 = m * 2;
			tmp = tree[_n2] < tree[_m2] || tree[_n2] == tree[_m2] && depth[n] <= depth[m];
		} else {
			tmp = false;
		}
		if(tmp) {
			++j;
		}
		var m1 = s.heap[j];
		var depth1 = s.depth;
		var _n21 = v * 2;
		var _m21 = m1 * 2;
		if(tree[_n21] < tree[_m21] || tree[_n21] == tree[_m21] && depth1[v] <= depth1[m1]) {
			break;
		}
		s.heap[k] = s.heap[j] & 65535;
		k = j;
		j <<= 1;
	}
	s.heap[k] = v & 65535;
};
pako_zlib_Trees.compress_block = function(s,ltree,dtree) {
	var dist;
	var lc;
	var lx = 0;
	var code;
	var extra;
	if(s.last_lit != 0) {
		while(true) {
			dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
			lc = s.pending_buf[s.l_buf + lx];
			++lx;
			if(dist == 0) {
				pako_zlib_Trees.send_bits(s,ltree[lc * 2],ltree[lc * 2 + 1]);
			} else {
				code = pako_zlib_Trees._length_code[lc];
				var c = code + 256 + 1;
				pako_zlib_Trees.send_bits(s,ltree[c * 2],ltree[c * 2 + 1]);
				extra = pako_zlib_Trees.extra_lbits[code];
				if(extra != 0) {
					lc -= pako_zlib_Trees.base_length[code];
					pako_zlib_Trees.send_bits(s,lc,extra);
				}
				--dist;
				code = dist < 256 ? pako_zlib_Trees._dist_code[dist] : pako_zlib_Trees._dist_code[256 + (dist >>> 7)];
				pako_zlib_Trees.send_bits(s,dtree[code * 2],dtree[code * 2 + 1]);
				extra = pako_zlib_Trees.extra_dbits[code];
				if(extra != 0) {
					dist -= pako_zlib_Trees.base_dist[code];
					pako_zlib_Trees.send_bits(s,dist,extra);
				}
			}
			if(!(lx < s.last_lit)) {
				break;
			}
		}
	}
	pako_zlib_Trees.send_bits(s,ltree[512],ltree[513]);
};
pako_zlib_Trees.build_tree = function(s,desc) {
	var tree = desc.dyn_tree;
	var stree = desc.stat_desc.static_tree;
	var has_stree = desc.stat_desc.has_stree;
	var elems = desc.stat_desc.elems;
	var m;
	var max_code = -1;
	var node;
	s.heap_len = 0;
	s.heap_max = 573;
	var _g1 = 0;
	while(_g1 < elems) {
		var n = _g1++;
		if(tree[n * 2] != 0) {
			max_code = n;
			s.heap[++s.heap_len] = n & 65535;
			s.depth[n] = 0;
		} else {
			tree[n * 2 + 1] = 0;
		}
	}
	while(s.heap_len < 2) {
		node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0) & 65535;
		tree[node * 2] = 1;
		s.depth[node] = 0;
		s.opt_len--;
		if(has_stree) {
			s.static_len -= stree[node * 2 + 1];
		}
	}
	desc.max_code = max_code;
	var n1 = s.heap_len >> 1;
	while(n1 >= 1) {
		pako_zlib_Trees.pqdownheap(s,tree,n1);
		--n1;
	}
	node = elems;
	while(true) {
		n1 = s.heap[1];
		s.heap[1] = s.heap[s.heap_len--] & 65535;
		pako_zlib_Trees.pqdownheap(s,tree,1);
		m = s.heap[1];
		s.heap[--s.heap_max] = n1 & 65535;
		s.heap[--s.heap_max] = m & 65535;
		tree[node * 2] = tree[n1 * 2] + tree[m * 2] & 65535;
		s.depth[node] = (s.depth[n1] >= s.depth[m] ? s.depth[n1] : s.depth[m]) + 1 & 65535;
		tree[n1 * 2 + 1] = (tree[m * 2 + 1] = node & 65535) & 65535;
		s.heap[1] = node++ & 65535;
		pako_zlib_Trees.pqdownheap(s,tree,1);
		if(!(s.heap_len >= 2)) {
			break;
		}
	}
	var tmp = s.heap[1] & 65535;
	s.heap[--s.heap_max] = tmp;
	pako_zlib_Trees.gen_bitlen(s,desc);
	pako_zlib_Trees.gen_codes(tree,max_code,s.bl_count);
};
pako_zlib_Trees.scan_tree = function(s,tree,max_code) {
	var prevlen = -1;
	var curlen;
	var nextlen = tree[1];
	var count = 0;
	var max_count = 7;
	var min_count = 4;
	if(nextlen == 0) {
		max_count = 138;
		min_count = 3;
	}
	tree[(max_code + 1) * 2 + 1] = 65535;
	var _g1 = 0;
	var _g = max_code + 1;
	while(_g1 < _g) {
		curlen = nextlen;
		nextlen = tree[(_g1++ + 1) * 2 + 1];
		if(++count < max_count && curlen == nextlen) {
			continue;
		} else if(count < min_count) {
			var _g2 = curlen * 2;
			var _g3 = s.bl_tree;
			_g3[_g2] = _g3[_g2] + count & 65535;
		} else if(curlen != 0) {
			if(curlen != prevlen) {
				var _g21 = curlen * 2;
				var _g31 = s.bl_tree;
				_g31[_g21] = _g31[_g21] + 1 & 65535;
			}
			var _g22 = s.bl_tree;
			_g22[32] = _g22[32] + 1 & 65535;
		} else if(count <= 10) {
			var _g23 = s.bl_tree;
			_g23[34] = _g23[34] + 1 & 65535;
		} else {
			var _g24 = s.bl_tree;
			_g24[36] = _g24[36] + 1 & 65535;
		}
		count = 0;
		prevlen = curlen;
		if(nextlen == 0) {
			max_count = 138;
			min_count = 3;
		} else if(curlen == nextlen) {
			max_count = 6;
			min_count = 3;
		} else {
			max_count = 7;
			min_count = 4;
		}
	}
};
pako_zlib_Trees.send_tree = function(s,tree,max_code) {
	var prevlen = -1;
	var curlen;
	var nextlen = tree[1];
	var count = 0;
	var max_count = 7;
	var min_count = 4;
	if(nextlen == 0) {
		max_count = 138;
		min_count = 3;
	}
	var _g1 = 0;
	var _g = max_code + 1;
	while(_g1 < _g) {
		curlen = nextlen;
		nextlen = tree[(_g1++ + 1) * 2 + 1];
		if(++count < max_count && curlen == nextlen) {
			continue;
		} else if(count < min_count) {
			while(true) {
				var tree1 = s.bl_tree;
				pako_zlib_Trees.send_bits(s,tree1[curlen * 2],tree1[curlen * 2 + 1]);
				if(!(--count != 0)) {
					break;
				}
			}
		} else if(curlen != 0) {
			if(curlen != prevlen) {
				var tree2 = s.bl_tree;
				pako_zlib_Trees.send_bits(s,tree2[curlen * 2],tree2[curlen * 2 + 1]);
				--count;
			}
			var tree3 = s.bl_tree;
			pako_zlib_Trees.send_bits(s,tree3[32],tree3[33]);
			pako_zlib_Trees.send_bits(s,count - 3,2);
		} else if(count <= 10) {
			var tree4 = s.bl_tree;
			pako_zlib_Trees.send_bits(s,tree4[34],tree4[35]);
			pako_zlib_Trees.send_bits(s,count - 3,3);
		} else {
			var tree5 = s.bl_tree;
			pako_zlib_Trees.send_bits(s,tree5[36],tree5[37]);
			pako_zlib_Trees.send_bits(s,count - 11,7);
		}
		count = 0;
		prevlen = curlen;
		if(nextlen == 0) {
			max_count = 138;
			min_count = 3;
		} else if(curlen == nextlen) {
			max_count = 6;
			min_count = 3;
		} else {
			max_count = 7;
			min_count = 4;
		}
	}
};
pako_zlib_Trees.build_bl_tree = function(s) {
	pako_zlib_Trees.scan_tree(s,s.dyn_ltree,s.l_desc.max_code);
	pako_zlib_Trees.scan_tree(s,s.dyn_dtree,s.d_desc.max_code);
	pako_zlib_Trees.build_tree(s,s.bl_desc);
	var max_blindex = 18;
	while(max_blindex >= 3) {
		if(s.bl_tree[pako_zlib_Trees.bl_order[max_blindex] * 2 + 1] != 0) {
			break;
		}
		--max_blindex;
	}
	s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
	return max_blindex;
};
pako_zlib_Trees.send_all_trees = function(s,lcodes,dcodes,blcodes) {
	pako_zlib_Trees.send_bits(s,lcodes - 257,5);
	pako_zlib_Trees.send_bits(s,dcodes - 1,5);
	pako_zlib_Trees.send_bits(s,blcodes - 4,4);
	var _g1 = 0;
	while(_g1 < blcodes) pako_zlib_Trees.send_bits(s,s.bl_tree[pako_zlib_Trees.bl_order[_g1++] * 2 + 1],3);
	pako_zlib_Trees.send_tree(s,s.dyn_ltree,lcodes - 1);
	pako_zlib_Trees.send_tree(s,s.dyn_dtree,dcodes - 1);
};
pako_zlib_Trees.detect_data_type = function(s) {
	var black_mask = -201342849;
	var n = 0;
	while(n <= 31) {
		if((black_mask & 1) == 1 && s.dyn_ltree[n * 2] != 0) {
			return 0;
		}
		++n;
		black_mask >>>= 1;
	}
	if(s.dyn_ltree[18] != 0 || s.dyn_ltree[20] != 0 || s.dyn_ltree[26] != 0) {
		return 1;
	}
	var _g = 32;
	while(_g < 256) if(s.dyn_ltree[_g++ * 2] != 0) {
		return 1;
	}
	return 0;
};
pako_zlib_Trees._tr_init = function(s) {
	if(!pako_zlib_Trees.static_init_done) {
		pako_zlib_Trees.tr_static_init();
		pako_zlib_Trees.static_init_done = true;
	}
	s.l_desc = new pako_zlib_TreeDesc(s.dyn_ltree,pako_zlib_Trees.static_l_desc);
	s.d_desc = new pako_zlib_TreeDesc(s.dyn_dtree,pako_zlib_Trees.static_d_desc);
	s.bl_desc = new pako_zlib_TreeDesc(s.bl_tree,pako_zlib_Trees.static_bl_desc);
	s.bi_buf = 0;
	s.bi_valid = 0;
	pako_zlib_Trees.init_block(s);
};
pako_zlib_Trees._tr_flush_block = function(s,buf,stored_len,last) {
	var opt_lenb;
	var static_lenb;
	var max_blindex = 0;
	if(s.level > 0) {
		if(s.strm.data_type == 2) {
			s.strm.data_type = pako_zlib_Trees.detect_data_type(s);
		}
		pako_zlib_Trees.build_tree(s,s.l_desc);
		pako_zlib_Trees.build_tree(s,s.d_desc);
		max_blindex = pako_zlib_Trees.build_bl_tree(s);
		opt_lenb = s.opt_len + 3 + 7 >>> 3;
		static_lenb = s.static_len + 3 + 7 >>> 3;
		if(static_lenb <= opt_lenb) {
			opt_lenb = static_lenb;
		}
	} else {
		static_lenb = stored_len + 5;
		opt_lenb = static_lenb;
	}
	if(stored_len + 4 <= opt_lenb && buf != -1) {
		pako_zlib_Trees.send_bits(s,last ? 1 : 0,3);
		pako_zlib_Trees.bi_windup(s);
		s.pending_buf[s.pending++] = stored_len & 255 & 255;
		s.pending_buf[s.pending++] = stored_len >>> 8 & 255 & 255;
		var w = ~stored_len;
		s.pending_buf[s.pending++] = w & 255 & 255;
		s.pending_buf[s.pending++] = w >>> 8 & 255 & 255;
		var dest = s.pending_buf;
		var src = s.window;
		var dest_offs = s.pending;
		haxe_io_Bytes.ofData(dest.buffer).blit(dest.byteOffset + dest_offs,haxe_io_Bytes.ofData(src.buffer),src.byteOffset + buf,stored_len);
		s.pending += stored_len;
	} else if(s.strategy == 4 || static_lenb == opt_lenb) {
		pako_zlib_Trees.send_bits(s,2 + (last ? 1 : 0),3);
		pako_zlib_Trees.compress_block(s,pako_zlib_Trees.static_ltree,pako_zlib_Trees.static_dtree);
	} else {
		pako_zlib_Trees.send_bits(s,4 + (last ? 1 : 0),3);
		pako_zlib_Trees.send_all_trees(s,s.l_desc.max_code + 1,s.d_desc.max_code + 1,max_blindex + 1);
		pako_zlib_Trees.compress_block(s,s.dyn_ltree,s.dyn_dtree);
	}
	pako_zlib_Trees.init_block(s);
	if(last) {
		pako_zlib_Trees.bi_windup(s);
	}
};
var pako_zlib_Config = function(good_length,max_lazy,nice_length,max_chain,func) {
	this.good_length = good_length;
	this.max_lazy = max_lazy;
	this.nice_length = nice_length;
	this.max_chain = max_chain;
	this.func = func;
};
pako_zlib_Config.__name__ = true;
var pako_zlib_Deflate = function() { };
pako_zlib_Deflate.__name__ = true;
pako_zlib_Deflate.flush_pending = function(strm) {
	var s = strm.deflateState;
	var len = s.pending;
	if(len > strm.avail_out) {
		len = strm.avail_out;
	}
	if(len == 0) {
		return;
	}
	var dest = strm.output;
	var src = s.pending_buf;
	var src_offs = s.pending_out;
	var dest_offs = strm.next_out;
	haxe_io_Bytes.ofData(dest.buffer).blit(dest.byteOffset + dest_offs,haxe_io_Bytes.ofData(src.buffer),src.byteOffset + src_offs,len);
	strm.next_out += len;
	s.pending_out += len;
	strm.total_out += len;
	strm.avail_out -= len;
	s.pending -= len;
	if(s.pending == 0) {
		s.pending_out = 0;
	}
};
pako_zlib_Deflate.read_buf = function(strm,buf,start,size) {
	var len = strm.avail_in;
	if(len > size) {
		len = size;
	}
	if(len == 0) {
		return 0;
	}
	strm.avail_in -= len;
	var dest = buf;
	var src = strm.input;
	var src_offs = strm.next_in;
	haxe_io_Bytes.ofData(dest.buffer).blit(dest.byteOffset + start,haxe_io_Bytes.ofData(src.buffer),src.byteOffset + src_offs,len);
	if(strm.deflateState.wrap == 1) {
		strm.adler = pako_zlib_Adler32.adler32(strm.adler,buf,len,start);
	} else if(strm.deflateState.wrap == 2) {
		strm.adler = pako_zlib_CRC32.crc32(strm.adler,buf,len,start);
	}
	strm.next_in += len;
	strm.total_in += len;
	return len;
};
pako_zlib_Deflate.longest_match = function(s,cur_match) {
	var chain_length = s.max_chain_length;
	var scan = s.strstart;
	var match;
	var len;
	var best_len = s.prev_length;
	var nice_match = s.nice_match;
	var limit = s.strstart > s.w_size - 262 ? s.strstart - (s.w_size - 262) : 0;
	var _win = s.window;
	var wmask = s.w_mask;
	var prev = s.prev;
	var strend = s.strstart + 258;
	var scan_end1 = _win[scan + best_len - 1];
	var scan_end = _win[scan + best_len];
	if(s.prev_length >= s.good_match) {
		chain_length >>= 2;
	}
	if(nice_match > s.lookahead) {
		nice_match = s.lookahead;
	}
	while(true) {
		match = cur_match;
		if(_win[match + best_len] != scan_end || _win[match + best_len - 1] != scan_end1 || _win[match] != _win[scan] || _win[++match] != _win[scan + 1]) {
			cur_match = prev[cur_match & wmask];
			if(!(cur_match > limit && --chain_length != 0)) {
				break;
			} else {
				continue;
			}
		}
		scan += 2;
		++match;
		while(_win[++scan] == _win[++match] && _win[++scan] == _win[++match] && _win[++scan] == _win[++match] && _win[++scan] == _win[++match] && _win[++scan] == _win[++match] && _win[++scan] == _win[++match] && _win[++scan] == _win[++match] && _win[++scan] == _win[++match] && scan < strend) {
		}
		len = 258 - (strend - scan);
		scan = strend - 258;
		if(len > best_len) {
			s.match_start = cur_match;
			best_len = len;
			if(len >= nice_match) {
				break;
			}
			scan_end1 = _win[scan + len - 1];
			scan_end = _win[scan + len];
		}
		cur_match = prev[cur_match & wmask];
		if(!(cur_match > limit && --chain_length != 0)) {
			break;
		}
	}
	if(best_len <= s.lookahead) {
		return best_len;
	}
	return s.lookahead;
};
pako_zlib_Deflate.fill_window = function(s) {
	var _w_size = s.w_size;
	var p;
	var n;
	var m;
	var more;
	var str;
	while(true) {
		more = s.window_size - s.lookahead - s.strstart;
		if(s.strstart >= _w_size + (_w_size - 262)) {
			var dest = s.window;
			var src = s.window;
			haxe_io_Bytes.ofData(dest.buffer).blit(dest.byteOffset,haxe_io_Bytes.ofData(src.buffer),src.byteOffset + _w_size,_w_size);
			s.match_start -= _w_size;
			s.strstart -= _w_size;
			s.block_start -= _w_size;
			n = s.hash_size;
			p = n;
			while(true) {
				m = s.head[--p];
				s.head[p] = (m >= _w_size ? m - _w_size : 0) & 65535;
				if(!(--n != 0)) {
					break;
				}
			}
			n = _w_size;
			p = _w_size;
			while(true) {
				m = s.prev[--p];
				s.prev[p] = (m >= _w_size ? m - _w_size : 0) & 65535;
				if(!(--n != 0)) {
					break;
				}
			}
			more += _w_size;
		}
		if(s.strm.avail_in == 0) {
			break;
		}
		n = pako_zlib_Deflate.read_buf(s.strm,s.window,s.strstart + s.lookahead,more);
		s.lookahead += n;
		if(s.lookahead + s.insert >= 3) {
			str = s.strstart - s.insert;
			s.ins_h = s.window[str];
			s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
			while(s.insert != 0) {
				s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 3 - 1]) & s.hash_mask;
				s.prev[str & s.w_mask] = s.head[s.ins_h] & 65535;
				s.head[s.ins_h] = str & 65535;
				++str;
				s.insert--;
				if(s.lookahead + s.insert < 3) {
					break;
				}
			}
		}
		if(!(s.lookahead < 262 && s.strm.avail_in != 0)) {
			break;
		}
	}
};
pako_zlib_Deflate.deflate_stored = function(s,flush) {
	var max_block_size = 65535;
	if(65535 > s.pending_buf_size - 5) {
		max_block_size = s.pending_buf_size - 5;
	}
	while(true) {
		if(s.lookahead <= 1) {
			pako_zlib_Deflate.fill_window(s);
			if(s.lookahead == 0 && flush == 0) {
				return 1;
			}
			if(s.lookahead == 0) {
				break;
			}
		}
		s.strstart += s.lookahead;
		s.lookahead = 0;
		var max_start = s.block_start + max_block_size;
		if(s.strstart == 0 || s.strstart >= max_start) {
			s.lookahead = s.strstart - max_start;
			s.strstart = max_start;
			pako_zlib_Trees._tr_flush_block(s,s.block_start >= 0 ? s.block_start : -1,s.strstart - s.block_start,false);
			s.block_start = s.strstart;
			pako_zlib_Deflate.flush_pending(s.strm);
			if(s.strm.avail_out == 0) {
				return 1;
			}
		}
		if(s.strstart - s.block_start >= s.w_size - 262) {
			pako_zlib_Trees._tr_flush_block(s,s.block_start >= 0 ? s.block_start : -1,s.strstart - s.block_start,false);
			s.block_start = s.strstart;
			pako_zlib_Deflate.flush_pending(s.strm);
			if(s.strm.avail_out == 0) {
				return 1;
			}
		}
	}
	s.insert = 0;
	if(flush == 4) {
		pako_zlib_Trees._tr_flush_block(s,s.block_start >= 0 ? s.block_start : -1,s.strstart - s.block_start,true);
		s.block_start = s.strstart;
		pako_zlib_Deflate.flush_pending(s.strm);
		if(s.strm.avail_out == 0) {
			return 3;
		}
		return 4;
	}
	if(s.strstart > s.block_start) {
		pako_zlib_Trees._tr_flush_block(s,s.block_start >= 0 ? s.block_start : -1,s.strstart - s.block_start,false);
		s.block_start = s.strstart;
		pako_zlib_Deflate.flush_pending(s.strm);
		if(s.strm.avail_out == 0) {
			return 1;
		}
	}
	return 1;
};
pako_zlib_Deflate.deflate_fast = function(s,flush) {
	var hash_head;
	var bflush;
	while(true) {
		if(s.lookahead < 262) {
			pako_zlib_Deflate.fill_window(s);
			if(s.lookahead < 262 && flush == 0) {
				return 1;
			}
			if(s.lookahead == 0) {
				break;
			}
		}
		hash_head = 0;
		if(s.lookahead >= 3) {
			s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 3 - 1]) & s.hash_mask;
			hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h] & 65535;
			s.head[s.ins_h] = s.strstart & 65535;
		}
		if(hash_head != 0 && s.strstart - hash_head <= s.w_size - 262) {
			s.match_length = pako_zlib_Deflate.longest_match(s,hash_head);
		}
		if(s.match_length >= 3) {
			var dist = s.strstart - s.match_start;
			var lc = s.match_length - 3;
			s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255 & 255;
			s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255 & 255;
			s.pending_buf[s.l_buf + s.last_lit] = lc & 255 & 255;
			s.last_lit++;
			if(dist == 0) {
				var _g = lc * 2;
				var _g1 = s.dyn_ltree;
				_g1[_g] = _g1[_g] + 1 & 65535;
			} else {
				s.matches++;
				--dist;
				var _g2 = (pako_zlib_Trees._length_code[lc] + 256 + 1) * 2;
				var _g11 = s.dyn_ltree;
				_g11[_g2] = _g11[_g2] + 1 & 65535;
				var _g3 = (dist < 256 ? pako_zlib_Trees._dist_code[dist] : pako_zlib_Trees._dist_code[256 + (dist >>> 7)]) * 2;
				var _g12 = s.dyn_dtree;
				_g12[_g3] = _g12[_g3] + 1 & 65535;
			}
			bflush = s.last_lit == s.lit_bufsize - 1;
			s.lookahead -= s.match_length;
			if(s.match_length <= s.max_lazy_match && s.lookahead >= 3) {
				s.match_length--;
				while(true) {
					s.strstart++;
					s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 3 - 1]) & s.hash_mask;
					hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h] & 65535;
					s.head[s.ins_h] = s.strstart & 65535;
					if(!(--s.match_length != 0)) {
						break;
					}
				}
				s.strstart++;
			} else {
				s.strstart += s.match_length;
				s.match_length = 0;
				s.ins_h = s.window[s.strstart];
				s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
			}
		} else {
			var lc1 = s.window[s.strstart];
			s.pending_buf[s.d_buf + s.last_lit * 2] = 0;
			s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = 0;
			s.pending_buf[s.l_buf + s.last_lit] = lc1 & 255 & 255;
			s.last_lit++;
			var _g4 = lc1 * 2;
			var _g13 = s.dyn_ltree;
			_g13[_g4] = _g13[_g4] + 1 & 65535;
			bflush = s.last_lit == s.lit_bufsize - 1;
			s.lookahead--;
			s.strstart++;
		}
		if(bflush) {
			pako_zlib_Trees._tr_flush_block(s,s.block_start >= 0 ? s.block_start : -1,s.strstart - s.block_start,false);
			s.block_start = s.strstart;
			pako_zlib_Deflate.flush_pending(s.strm);
			if(s.strm.avail_out == 0) {
				return 1;
			}
		}
	}
	s.insert = s.strstart < 2 ? s.strstart : 2;
	if(flush == 4) {
		pako_zlib_Trees._tr_flush_block(s,s.block_start >= 0 ? s.block_start : -1,s.strstart - s.block_start,true);
		s.block_start = s.strstart;
		pako_zlib_Deflate.flush_pending(s.strm);
		if(s.strm.avail_out == 0) {
			return 3;
		}
		return 4;
	}
	if(s.last_lit != 0) {
		pako_zlib_Trees._tr_flush_block(s,s.block_start >= 0 ? s.block_start : -1,s.strstart - s.block_start,false);
		s.block_start = s.strstart;
		pako_zlib_Deflate.flush_pending(s.strm);
		if(s.strm.avail_out == 0) {
			return 1;
		}
	}
	return 2;
};
pako_zlib_Deflate.deflate_slow = function(s,flush) {
	var hash_head;
	var bflush;
	var max_insert;
	while(true) {
		if(s.lookahead < 262) {
			pako_zlib_Deflate.fill_window(s);
			if(s.lookahead < 262 && flush == 0) {
				return 1;
			}
			if(s.lookahead == 0) {
				break;
			}
		}
		hash_head = 0;
		if(s.lookahead >= 3) {
			s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 3 - 1]) & s.hash_mask;
			hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h] & 65535;
			s.head[s.ins_h] = s.strstart & 65535;
		}
		s.prev_length = s.match_length;
		s.prev_match = s.match_start;
		s.match_length = 2;
		if(hash_head != 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - 262) {
			s.match_length = pako_zlib_Deflate.longest_match(s,hash_head);
			if(s.match_length <= 5 && (s.strategy == 1 || s.match_length == 3 && s.strstart - s.match_start > 4096)) {
				s.match_length = 2;
			}
		}
		if(s.prev_length >= 3 && s.match_length <= s.prev_length) {
			max_insert = s.strstart + s.lookahead - 3;
			var dist = s.strstart - 1 - s.prev_match;
			var lc = s.prev_length - 3;
			s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255 & 255;
			s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255 & 255;
			s.pending_buf[s.l_buf + s.last_lit] = lc & 255 & 255;
			s.last_lit++;
			if(dist == 0) {
				var _g = lc * 2;
				var _g1 = s.dyn_ltree;
				_g1[_g] = _g1[_g] + 1 & 65535;
			} else {
				s.matches++;
				--dist;
				var _g2 = (pako_zlib_Trees._length_code[lc] + 256 + 1) * 2;
				var _g11 = s.dyn_ltree;
				_g11[_g2] = _g11[_g2] + 1 & 65535;
				var _g3 = (dist < 256 ? pako_zlib_Trees._dist_code[dist] : pako_zlib_Trees._dist_code[256 + (dist >>> 7)]) * 2;
				var _g12 = s.dyn_dtree;
				_g12[_g3] = _g12[_g3] + 1 & 65535;
			}
			bflush = s.last_lit == s.lit_bufsize - 1;
			s.lookahead -= s.prev_length - 1;
			s.prev_length -= 2;
			while(true) {
				if(++s.strstart <= max_insert) {
					s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 3 - 1]) & s.hash_mask;
					hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h] & 65535;
					s.head[s.ins_h] = s.strstart & 65535;
				}
				if(!(--s.prev_length != 0)) {
					break;
				}
			}
			s.match_available = false;
			s.match_length = 2;
			s.strstart++;
			if(bflush) {
				pako_zlib_Trees._tr_flush_block(s,s.block_start >= 0 ? s.block_start : -1,s.strstart - s.block_start,false);
				s.block_start = s.strstart;
				pako_zlib_Deflate.flush_pending(s.strm);
				if(s.strm.avail_out == 0) {
					return 1;
				}
			}
		} else if(s.match_available) {
			var lc1 = s.window[s.strstart - 1];
			s.pending_buf[s.d_buf + s.last_lit * 2] = 0;
			s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = 0;
			s.pending_buf[s.l_buf + s.last_lit] = lc1 & 255 & 255;
			s.last_lit++;
			var _g4 = lc1 * 2;
			var _g13 = s.dyn_ltree;
			_g13[_g4] = _g13[_g4] + 1 & 65535;
			bflush = s.last_lit == s.lit_bufsize - 1;
			if(bflush) {
				pako_zlib_Trees._tr_flush_block(s,s.block_start >= 0 ? s.block_start : -1,s.strstart - s.block_start,false);
				s.block_start = s.strstart;
				pako_zlib_Deflate.flush_pending(s.strm);
			}
			s.strstart++;
			s.lookahead--;
			if(s.strm.avail_out == 0) {
				return 1;
			}
		} else {
			s.match_available = true;
			s.strstart++;
			s.lookahead--;
		}
	}
	if(s.match_available) {
		var lc2 = s.window[s.strstart - 1];
		s.pending_buf[s.d_buf + s.last_lit * 2] = 0;
		s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = 0;
		s.pending_buf[s.l_buf + s.last_lit] = lc2 & 255 & 255;
		s.last_lit++;
		var _g5 = lc2 * 2;
		var _g14 = s.dyn_ltree;
		_g14[_g5] = _g14[_g5] + 1 & 65535;
		s.match_available = false;
	}
	s.insert = s.strstart < 2 ? s.strstart : 2;
	if(flush == 4) {
		pako_zlib_Trees._tr_flush_block(s,s.block_start >= 0 ? s.block_start : -1,s.strstart - s.block_start,true);
		s.block_start = s.strstart;
		pako_zlib_Deflate.flush_pending(s.strm);
		if(s.strm.avail_out == 0) {
			return 3;
		}
		return 4;
	}
	if(s.last_lit != 0) {
		pako_zlib_Trees._tr_flush_block(s,s.block_start >= 0 ? s.block_start : -1,s.strstart - s.block_start,false);
		s.block_start = s.strstart;
		pako_zlib_Deflate.flush_pending(s.strm);
		if(s.strm.avail_out == 0) {
			return 1;
		}
	}
	return 2;
};
pako_zlib_Deflate.deflate_rle = function(s,flush) {
	var bflush;
	var prev;
	var scan;
	var strend;
	var _win = s.window;
	while(true) {
		if(s.lookahead <= 258) {
			pako_zlib_Deflate.fill_window(s);
			if(s.lookahead <= 258 && flush == 0) {
				return 1;
			}
			if(s.lookahead == 0) {
				break;
			}
		}
		s.match_length = 0;
		if(s.lookahead >= 3 && s.strstart > 0) {
			scan = s.strstart - 1;
			prev = _win[scan];
			if(prev == _win[++scan] && prev == _win[++scan] && prev == _win[++scan]) {
				strend = s.strstart + 258;
				while(prev == _win[++scan] && prev == _win[++scan] && prev == _win[++scan] && prev == _win[++scan] && prev == _win[++scan] && prev == _win[++scan] && prev == _win[++scan] && prev == _win[++scan] && scan < strend) {
				}
				s.match_length = 258 - (strend - scan);
				if(s.match_length > s.lookahead) {
					s.match_length = s.lookahead;
				}
			}
		}
		if(s.match_length >= 3) {
			var lc = s.match_length - 3;
			s.pending_buf[s.d_buf + s.last_lit * 2] = 0;
			s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = 1;
			s.pending_buf[s.l_buf + s.last_lit] = lc & 255 & 255;
			s.last_lit++;
			s.matches++;
			var _g = (pako_zlib_Trees._length_code[lc] + 256 + 1) * 2;
			var _g1 = s.dyn_ltree;
			_g1[_g] = _g1[_g] + 1 & 65535;
			var _g2 = pako_zlib_Trees._dist_code[0] * 2;
			var _g11 = s.dyn_dtree;
			_g11[_g2] = _g11[_g2] + 1 & 65535;
			bflush = s.last_lit == s.lit_bufsize - 1;
			s.lookahead -= s.match_length;
			s.strstart += s.match_length;
			s.match_length = 0;
		} else {
			var lc1 = s.window[s.strstart];
			s.pending_buf[s.d_buf + s.last_lit * 2] = 0;
			s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = 0;
			s.pending_buf[s.l_buf + s.last_lit] = lc1 & 255 & 255;
			s.last_lit++;
			var _g3 = lc1 * 2;
			var _g12 = s.dyn_ltree;
			_g12[_g3] = _g12[_g3] + 1 & 65535;
			bflush = s.last_lit == s.lit_bufsize - 1;
			s.lookahead--;
			s.strstart++;
		}
		if(bflush) {
			pako_zlib_Trees._tr_flush_block(s,s.block_start >= 0 ? s.block_start : -1,s.strstart - s.block_start,false);
			s.block_start = s.strstart;
			pako_zlib_Deflate.flush_pending(s.strm);
			if(s.strm.avail_out == 0) {
				return 1;
			}
		}
	}
	s.insert = 0;
	if(flush == 4) {
		pako_zlib_Trees._tr_flush_block(s,s.block_start >= 0 ? s.block_start : -1,s.strstart - s.block_start,true);
		s.block_start = s.strstart;
		pako_zlib_Deflate.flush_pending(s.strm);
		if(s.strm.avail_out == 0) {
			return 3;
		}
		return 4;
	}
	if(s.last_lit != 0) {
		pako_zlib_Trees._tr_flush_block(s,s.block_start >= 0 ? s.block_start : -1,s.strstart - s.block_start,false);
		s.block_start = s.strstart;
		pako_zlib_Deflate.flush_pending(s.strm);
		if(s.strm.avail_out == 0) {
			return 1;
		}
	}
	return 2;
};
pako_zlib_Deflate.deflate_huff = function(s,flush) {
	var bflush;
	while(true) {
		if(s.lookahead == 0) {
			pako_zlib_Deflate.fill_window(s);
			if(s.lookahead == 0) {
				if(flush == 0) {
					return 1;
				}
				break;
			}
		}
		s.match_length = 0;
		var lc = s.window[s.strstart];
		s.pending_buf[s.d_buf + s.last_lit * 2] = 0;
		s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = 0;
		s.pending_buf[s.l_buf + s.last_lit] = lc & 255 & 255;
		s.last_lit++;
		var _g = lc * 2;
		var _g1 = s.dyn_ltree;
		_g1[_g] = _g1[_g] + 1 & 65535;
		bflush = s.last_lit == s.lit_bufsize - 1;
		s.lookahead--;
		s.strstart++;
		if(bflush) {
			pako_zlib_Trees._tr_flush_block(s,s.block_start >= 0 ? s.block_start : -1,s.strstart - s.block_start,false);
			s.block_start = s.strstart;
			pako_zlib_Deflate.flush_pending(s.strm);
			if(s.strm.avail_out == 0) {
				return 1;
			}
		}
	}
	s.insert = 0;
	if(flush == 4) {
		pako_zlib_Trees._tr_flush_block(s,s.block_start >= 0 ? s.block_start : -1,s.strstart - s.block_start,true);
		s.block_start = s.strstart;
		pako_zlib_Deflate.flush_pending(s.strm);
		if(s.strm.avail_out == 0) {
			return 3;
		}
		return 4;
	}
	if(s.last_lit != 0) {
		pako_zlib_Trees._tr_flush_block(s,s.block_start >= 0 ? s.block_start : -1,s.strstart - s.block_start,false);
		s.block_start = s.strstart;
		pako_zlib_Deflate.flush_pending(s.strm);
		if(s.strm.avail_out == 0) {
			return 1;
		}
	}
	return 2;
};
pako_zlib_Deflate.lm_init = function(s) {
	s.window_size = 2 * s.w_size;
	var buf = s.head;
	var start = buf.byteOffset;
	var len = buf.byteLength;
	haxe_io_Bytes.ofData(buf.buffer).fill(start,len,0);
	s.max_lazy_match = pako_zlib_Deflate.configuration_table[s.level].max_lazy;
	s.good_match = pako_zlib_Deflate.configuration_table[s.level].good_length;
	s.nice_match = pako_zlib_Deflate.configuration_table[s.level].nice_length;
	s.max_chain_length = pako_zlib_Deflate.configuration_table[s.level].max_chain;
	s.strstart = 0;
	s.block_start = 0;
	s.lookahead = 0;
	s.insert = 0;
	s.match_length = s.prev_length = 2;
	s.match_available = false;
	s.ins_h = 0;
};
pako_zlib_Deflate.deflateResetKeep = function(strm) {
	if(strm == null || strm.deflateState == null) {
		strm.msg = pako_zlib_Messages.get(-2);
		return -2;
	}
	strm.total_in = strm.total_out = 0;
	strm.data_type = 2;
	var s = strm.deflateState;
	s.pending = 0;
	s.pending_out = 0;
	if(s.wrap < 0) {
		s.wrap = -s.wrap;
	}
	s.status = s.wrap != 0 ? 42 : 113;
	strm.adler = s.wrap == 2 ? 0 : 1;
	s.last_flush = 0;
	pako_zlib_Trees._tr_init(s);
	return 0;
};
pako_zlib_Deflate.deflateReset = function(strm) {
	var ret = pako_zlib_Deflate.deflateResetKeep(strm);
	if(ret == 0) {
		pako_zlib_Deflate.lm_init(strm.deflateState);
	}
	return ret;
};
pako_zlib_Deflate.deflateSetHeader = function(strm,head) {
	if(strm == null || strm.deflateState == null) {
		return -2;
	}
	if(strm.deflateState.wrap != 2) {
		return -2;
	}
	strm.deflateState.gzhead = head;
	return 0;
};
pako_zlib_Deflate.deflateInit2 = function(strm,level,method,windowBits,memLevel,strategy) {
	if(strm == null) {
		return -2;
	}
	var wrap = 1;
	if(level == -1) {
		level = 6;
	}
	if(windowBits < 0) {
		wrap = 0;
		windowBits = -windowBits;
	} else if(windowBits > 15) {
		wrap = 2;
		windowBits -= 16;
	}
	if(memLevel < 1 || memLevel > 9 || method != 8 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > 4) {
		strm.msg = pako_zlib_Messages.get(-2);
		return -2;
	}
	if(windowBits == 8) {
		windowBits = 9;
	}
	var s = new pako_zlib_DeflateState();
	strm.deflateState = s;
	s.strm = strm;
	s.wrap = wrap;
	s.gzhead = null;
	s.w_bits = windowBits;
	s.w_size = 1 << s.w_bits;
	s.w_mask = s.w_size - 1;
	s.hash_bits = memLevel + 7;
	s.hash_size = 1 << s.hash_bits;
	s.hash_mask = s.hash_size - 1;
	s.hash_shift = ~(~((s.hash_bits + 3 - 1) / 3 | 0));
	s.window = new Uint8Array(s.w_size * 2);
	s.head = new Uint16Array(s.hash_size);
	s.prev = new Uint16Array(s.w_size);
	s.lit_bufsize = 1 << memLevel + 6;
	s.pending_buf_size = s.lit_bufsize * 4;
	s.pending_buf = new Uint8Array(s.pending_buf_size);
	s.d_buf = s.lit_bufsize;
	s.l_buf = 3 * s.lit_bufsize;
	s.level = level;
	s.strategy = strategy;
	s.method = method;
	return pako_zlib_Deflate.deflateReset(strm);
};
pako_zlib_Deflate.deflate = function(strm,flush) {
	var beg;
	var val;
	if(strm == null || strm.deflateState == null || flush > 5 || flush < 0) {
		if(strm != null) {
			strm.msg = pako_zlib_Messages.get(-2);
			return -2;
		} else {
			return -2;
		}
	}
	var s = strm.deflateState;
	if(strm.output == null || strm.input == null && strm.avail_in != 0 || s.status == 666 && flush != 4) {
		var errorCode = strm.avail_out == 0 ? -5 : -2;
		strm.msg = pako_zlib_Messages.get(errorCode);
		return errorCode;
	}
	s.strm = strm;
	var old_flush = s.last_flush;
	s.last_flush = flush;
	if(s.status == 42) {
		if(s.wrap == 2) {
			strm.adler = 0;
			s.pending_buf[s.pending++] = 31;
			s.pending_buf[s.pending++] = 139;
			s.pending_buf[s.pending++] = 8;
			if(s.gzhead == null) {
				s.pending_buf[s.pending++] = 0;
				s.pending_buf[s.pending++] = 0;
				s.pending_buf[s.pending++] = 0;
				s.pending_buf[s.pending++] = 0;
				s.pending_buf[s.pending++] = 0;
				s.pending_buf[s.pending++] = (s.level == 9 ? 2 : s.strategy >= 2 || s.level < 2 ? 4 : 0) & 255;
				s.pending_buf[s.pending++] = 3;
				s.status = 113;
			} else {
				s.pending_buf[s.pending++] = (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc != 0 ? 2 : 0) + (s.gzhead.extra == null ? 0 : 4) + (s.gzhead.name == null || s.gzhead.name == "" ? 0 : 8) + (s.gzhead.comment == null || s.gzhead.comment == "" ? 0 : 16) & 255;
				s.pending_buf[s.pending++] = s.gzhead.time & 255 & 255;
				s.pending_buf[s.pending++] = s.gzhead.time >> 8 & 255 & 255;
				s.pending_buf[s.pending++] = s.gzhead.time >> 16 & 255 & 255;
				s.pending_buf[s.pending++] = s.gzhead.time >> 24 & 255 & 255;
				s.pending_buf[s.pending++] = (s.level == 9 ? 2 : s.strategy >= 2 || s.level < 2 ? 4 : 0) & 255;
				s.pending_buf[s.pending++] = s.gzhead.os & 255 & 255;
				if(s.gzhead.extra != null && s.gzhead.extra.length > 0) {
					s.pending_buf[s.pending++] = s.gzhead.extra.length & 255 & 255;
					s.pending_buf[s.pending++] = s.gzhead.extra.length >> 8 & 255 & 255;
				}
				if(s.gzhead.hcrc != 0) {
					strm.adler = pako_zlib_CRC32.crc32(strm.adler,s.pending_buf,s.pending,0);
				}
				s.gzindex = 0;
				s.status = 69;
			}
		} else {
			var header = 8 + (s.w_bits - 8 << 4) << 8;
			var level_flags = -1;
			if(s.strategy >= 2 || s.level < 2) {
				level_flags = 0;
			} else if(s.level < 6) {
				level_flags = 1;
			} else if(s.level == 6) {
				level_flags = 2;
			} else {
				level_flags = 3;
			}
			header |= level_flags << 6;
			if(s.strstart != 0) {
				header |= 32;
			}
			header += 31 - header % 31;
			s.status = 113;
			s.pending_buf[s.pending++] = header >>> 8 & 255 & 255;
			s.pending_buf[s.pending++] = header & 255 & 255;
			if(s.strstart != 0) {
				var b = strm.adler >>> 16;
				s.pending_buf[s.pending++] = b >>> 8 & 255 & 255;
				s.pending_buf[s.pending++] = b & 255 & 255;
				var b1 = strm.adler & 65535;
				s.pending_buf[s.pending++] = b1 >>> 8 & 255 & 255;
				s.pending_buf[s.pending++] = b1 & 255 & 255;
			}
			strm.adler = 1;
		}
	}
	if(s.status == 69) {
		if(s.gzhead.extra != null) {
			beg = s.pending;
			while(s.gzindex < (s.gzhead.extra.length & 65535)) {
				if(s.pending == s.pending_buf_size) {
					if(s.gzhead.hcrc != 0 && s.pending > beg) {
						strm.adler = pako_zlib_CRC32.crc32(strm.adler,s.pending_buf,s.pending - beg,beg);
					}
					pako_zlib_Deflate.flush_pending(strm);
					beg = s.pending;
					if(s.pending == s.pending_buf_size) {
						break;
					}
				}
				var b2 = s.gzhead.extra[s.gzindex] & 255;
				s.pending_buf[s.pending++] = b2 & 255;
				s.gzindex++;
			}
			if(s.gzhead.hcrc != 0 && s.pending > beg) {
				strm.adler = pako_zlib_CRC32.crc32(strm.adler,s.pending_buf,s.pending - beg,beg);
			}
			if(s.gzindex == s.gzhead.extra.length) {
				s.gzindex = 0;
				s.status = 73;
			}
		} else {
			s.status = 73;
		}
	}
	if(s.status == 73) {
		if(s.gzhead.name != null && s.gzhead.name != "") {
			beg = s.pending;
			while(true) {
				if(s.pending == s.pending_buf_size) {
					if(s.gzhead.hcrc != 0 && s.pending > beg) {
						strm.adler = pako_zlib_CRC32.crc32(strm.adler,s.pending_buf,s.pending - beg,beg);
					}
					pako_zlib_Deflate.flush_pending(strm);
					beg = s.pending;
					if(s.pending == s.pending_buf_size) {
						val = 1;
						break;
					}
				}
				if(s.gzindex < s.gzhead.name.length) {
					val = HxOverrides.cca(s.gzhead.name,s.gzindex++) & 255;
				} else {
					val = 0;
				}
				s.pending_buf[s.pending++] = val & 255;
				if(!(val != 0)) {
					break;
				}
			}
			if(s.gzhead.hcrc != 0 && s.pending > beg) {
				strm.adler = pako_zlib_CRC32.crc32(strm.adler,s.pending_buf,s.pending - beg,beg);
			}
			if(val == 0) {
				s.gzindex = 0;
				s.status = 91;
			}
		} else {
			s.status = 91;
		}
	}
	if(s.status == 91) {
		if(s.gzhead.comment != null && s.gzhead.comment != "") {
			beg = s.pending;
			while(true) {
				if(s.pending == s.pending_buf_size) {
					if(s.gzhead.hcrc != 0 && s.pending > beg) {
						strm.adler = pako_zlib_CRC32.crc32(strm.adler,s.pending_buf,s.pending - beg,beg);
					}
					pako_zlib_Deflate.flush_pending(strm);
					beg = s.pending;
					if(s.pending == s.pending_buf_size) {
						val = 1;
						break;
					}
				}
				if(s.gzindex < s.gzhead.comment.length) {
					val = HxOverrides.cca(s.gzhead.comment,s.gzindex++) & 255;
				} else {
					val = 0;
				}
				s.pending_buf[s.pending++] = val & 255;
				if(!(val != 0)) {
					break;
				}
			}
			if(s.gzhead.hcrc != 0 && s.pending > beg) {
				strm.adler = pako_zlib_CRC32.crc32(strm.adler,s.pending_buf,s.pending - beg,beg);
			}
			if(val == 0) {
				s.status = 103;
			}
		} else {
			s.status = 103;
		}
	}
	if(s.status == 103) {
		if(s.gzhead.hcrc != 0) {
			if(s.pending + 2 > s.pending_buf_size) {
				pako_zlib_Deflate.flush_pending(strm);
			}
			if(s.pending + 2 <= s.pending_buf_size) {
				s.pending_buf[s.pending++] = strm.adler & 255 & 255;
				s.pending_buf[s.pending++] = strm.adler >> 8 & 255 & 255;
				strm.adler = 0;
				s.status = 113;
			}
		} else {
			s.status = 113;
		}
	}
	if(s.pending != 0) {
		pako_zlib_Deflate.flush_pending(strm);
		if(strm.avail_out == 0) {
			s.last_flush = -1;
			return 0;
		}
	} else if(strm.avail_in == 0 && (flush << 1) - (flush > 4 ? 9 : 0) <= (old_flush << 1) - (old_flush > 4 ? 9 : 0) && flush != 4) {
		strm.msg = pako_zlib_Messages.get(-5);
		return -5;
	}
	if(s.status == 666 && strm.avail_in != 0) {
		strm.msg = pako_zlib_Messages.get(-5);
		return -5;
	}
	if(strm.avail_in != 0 || s.lookahead != 0 || flush != 0 && s.status != 666) {
		var bstate = s.strategy == 2 ? pako_zlib_Deflate.deflate_huff(s,flush) : s.strategy == 3 ? pako_zlib_Deflate.deflate_rle(s,flush) : pako_zlib_Deflate.configuration_table[s.level].func(s,flush);
		if(bstate == 3 || bstate == 4) {
			s.status = 666;
		}
		if(bstate == 1 || bstate == 3) {
			if(strm.avail_out == 0) {
				s.last_flush = -1;
			}
			return 0;
		}
		if(bstate == 2) {
			if(flush == 1) {
				pako_zlib_Trees.send_bits(s,2,3);
				var tree = pako_zlib_Trees.static_ltree;
				pako_zlib_Trees.send_bits(s,tree[512],tree[513]);
				pako_zlib_Trees.bi_flush(s);
			} else if(flush != 5) {
				pako_zlib_Trees.send_bits(s,0,3);
				pako_zlib_Trees.bi_windup(s);
				s.pending_buf[s.pending++] = 0;
				s.pending_buf[s.pending++] = 0;
				s.pending_buf[s.pending++] = 255;
				s.pending_buf[s.pending++] = 255;
				var dest = s.pending_buf;
				var src = s.window;
				var dest_offs = s.pending;
				haxe_io_Bytes.ofData(dest.buffer).blit(dest.byteOffset + dest_offs,haxe_io_Bytes.ofData(src.buffer),src.byteOffset,0);
				s.pending += 0;
				if(flush == 3) {
					var buf = s.head;
					var start = buf.byteOffset;
					var len = buf.byteLength;
					haxe_io_Bytes.ofData(buf.buffer).fill(start,len,0);
					if(s.lookahead == 0) {
						s.strstart = 0;
						s.block_start = 0;
						s.insert = 0;
					}
				}
			}
			pako_zlib_Deflate.flush_pending(strm);
			if(strm.avail_out == 0) {
				s.last_flush = -1;
				return 0;
			}
		}
	}
	if(flush != 4) {
		return 0;
	}
	if(s.wrap <= 0) {
		return 1;
	}
	if(s.wrap == 2) {
		s.pending_buf[s.pending++] = strm.adler & 255 & 255;
		s.pending_buf[s.pending++] = strm.adler >> 8 & 255 & 255;
		s.pending_buf[s.pending++] = strm.adler >> 16 & 255 & 255;
		s.pending_buf[s.pending++] = strm.adler >> 24 & 255 & 255;
		s.pending_buf[s.pending++] = strm.total_in & 255 & 255;
		s.pending_buf[s.pending++] = strm.total_in >> 8 & 255 & 255;
		s.pending_buf[s.pending++] = strm.total_in >> 16 & 255 & 255;
		s.pending_buf[s.pending++] = strm.total_in >> 24 & 255 & 255;
	} else {
		var b3 = strm.adler >>> 16;
		s.pending_buf[s.pending++] = b3 >>> 8 & 255 & 255;
		s.pending_buf[s.pending++] = b3 & 255 & 255;
		var b4 = strm.adler & 65535;
		s.pending_buf[s.pending++] = b4 >>> 8 & 255 & 255;
		s.pending_buf[s.pending++] = b4 & 255 & 255;
	}
	pako_zlib_Deflate.flush_pending(strm);
	if(s.wrap > 0) {
		s.wrap = -s.wrap;
	}
	if(s.pending != 0) {
		return 0;
	} else {
		return 1;
	}
};
pako_zlib_Deflate.deflateEnd = function(strm) {
	if(strm == null || strm.deflateState == null) {
		return -2;
	}
	var status = strm.deflateState.status;
	if(status != 42 && status != 69 && status != 73 && status != 91 && status != 103 && status != 113 && status != 666) {
		strm.msg = pako_zlib_Messages.get(-2);
		return -2;
	}
	strm.deflateState = null;
	if(status == 113) {
		strm.msg = pako_zlib_Messages.get(-3);
		return -3;
	} else {
		return 0;
	}
};
pako_zlib_Deflate.deflateSetDictionary = function(strm,dictionary) {
	var dictLength = dictionary.length;
	var str;
	var n;
	var tmpDict;
	if(strm == null || strm.deflateState == null) {
		return -2;
	}
	var s = strm.deflateState;
	var wrap = s.wrap;
	if(wrap == 2 || wrap == 1 && s.status != 42 || s.lookahead > 0) {
		return -2;
	}
	if(wrap == 1) {
		strm.adler = pako_zlib_Adler32.adler32(strm.adler,dictionary,dictLength,0);
	}
	s.wrap = 0;
	if(dictLength >= s.w_size) {
		if(wrap == 0) {
			var buf = s.head;
			var start = buf.byteOffset;
			var len = buf.byteLength;
			haxe_io_Bytes.ofData(buf.buffer).fill(start,len,0);
			s.strstart = 0;
			s.block_start = 0;
			s.insert = 0;
		}
		tmpDict = new Uint8Array(s.w_size);
		var dest = tmpDict;
		var src = dictionary;
		var src_offs = dictLength - s.w_size;
		var len1 = s.w_size;
		haxe_io_Bytes.ofData(dest.buffer).blit(dest.byteOffset,haxe_io_Bytes.ofData(src.buffer),src.byteOffset + src_offs,len1);
		dictionary = tmpDict;
		dictLength = s.w_size;
	}
	var avail = strm.avail_in;
	var next = strm.next_in;
	var input = strm.input;
	strm.avail_in = dictLength;
	strm.next_in = 0;
	strm.input = dictionary;
	pako_zlib_Deflate.fill_window(s);
	while(s.lookahead >= 3) {
		str = s.strstart;
		n = s.lookahead - 2;
		while(true) {
			s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 3 - 1]) & s.hash_mask;
			s.prev[str & s.w_mask] = s.head[s.ins_h] & 65535;
			s.head[s.ins_h] = str & 65535;
			++str;
			if(!(--n != 0)) {
				break;
			}
		}
		s.strstart = str;
		s.lookahead = 2;
		pako_zlib_Deflate.fill_window(s);
	}
	s.strstart += s.lookahead;
	s.block_start = s.strstart;
	s.insert = s.lookahead;
	s.lookahead = 0;
	s.match_length = s.prev_length = 2;
	s.match_available = false;
	strm.next_in = next;
	strm.input = input;
	strm.avail_in = avail;
	s.wrap = wrap;
	return 0;
};
var pako_zlib_DeflateState = function() {
	this.bi_valid = 0;
	this.bi_buf = 0;
	this.insert = 0;
	this.matches = 0;
	this.static_len = 0;
	this.opt_len = 0;
	this.d_buf = 0;
	this.last_lit = 0;
	this.lit_bufsize = 0;
	this.l_buf = 0;
	this.depth = new Uint16Array(573);
	this.heap_max = 0;
	this.heap_len = 0;
	this.heap = new Uint16Array(573);
	this.bl_count = new Uint16Array(16);
	this.bl_desc = null;
	this.d_desc = null;
	this.l_desc = null;
	this.bl_tree = new Uint16Array(78);
	this.dyn_dtree = new Uint16Array(122);
	this.dyn_ltree = new Uint16Array(1146);
	this.nice_match = 0;
	this.good_match = 0;
	this.strategy = 0;
	this.level = 0;
	this.max_lazy_match = 0;
	this.max_chain_length = 0;
	this.prev_length = 0;
	this.lookahead = 0;
	this.match_start = 0;
	this.strstart = 0;
	this.match_available = false;
	this.prev_match = 0;
	this.match_length = 0;
	this.block_start = 0;
	this.hash_shift = 0;
	this.hash_mask = 0;
	this.hash_bits = 0;
	this.hash_size = 0;
	this.ins_h = 0;
	this.head = null;
	this.prev = null;
	this.window_size = 0;
	this.window = null;
	this.w_mask = 0;
	this.w_bits = 0;
	this.w_size = 0;
	this.last_flush = -1;
	this.method = 8;
	this.gzindex = 0;
	this.gzhead = null;
	this.wrap = 0;
	this.pending = 0;
	this.pending_out = 0;
	this.pending_buf_size = 0;
	this.pending_buf = null;
	this.status = 0;
	this.strm = null;
	var buf = this.dyn_ltree;
	var start = buf.byteOffset;
	var len = buf.byteLength;
	haxe_io_Bytes.ofData(buf.buffer).fill(start,len,0);
	var buf1 = this.dyn_dtree;
	var start1 = buf1.byteOffset;
	var len1 = buf1.byteLength;
	haxe_io_Bytes.ofData(buf1.buffer).fill(start1,len1,0);
	var buf2 = this.bl_tree;
	var start2 = buf2.byteOffset;
	var len2 = buf2.byteLength;
	haxe_io_Bytes.ofData(buf2.buffer).fill(start2,len2,0);
	var buf3 = this.heap;
	var start3 = buf3.byteOffset;
	var len3 = buf3.byteLength;
	haxe_io_Bytes.ofData(buf3.buffer).fill(start3,len3,0);
	var buf4 = this.depth;
	var start4 = buf4.byteOffset;
	var len4 = buf4.byteLength;
	haxe_io_Bytes.ofData(buf4.buffer).fill(start4,len4,0);
};
pako_zlib_DeflateState.__name__ = true;
var pako_zlib_GZHeader = function() {
	this.hcrc = 0;
	this.comment = "";
	this.name = "";
	this.extra = null;
	this.os = 0;
	this.time = 0;
	this.text = false;
};
pako_zlib_GZHeader.__name__ = true;
var pako_zlib_Messages = function() { };
pako_zlib_Messages.__name__ = true;
pako_zlib_Messages.get = function(error) {
	return "ERROR: " + pako_zlib_Messages.map.h[error];
};
var pako_zlib_StaticTreeDesc = function(static_tree,extra_bits,extra_base,elems,max_length) {
	this.static_tree = static_tree;
	this.extra_bits = extra_bits;
	this.extra_base = extra_base;
	this.elems = elems;
	this.max_length = max_length;
	this.has_stree = static_tree != null && static_tree.length > 0;
};
pako_zlib_StaticTreeDesc.__name__ = true;
var pako_zlib_TreeDesc = function(dyn_tree,stat_desc) {
	this.dyn_tree = dyn_tree;
	this.max_code = 0;
	this.stat_desc = stat_desc;
};
pako_zlib_TreeDesc.__name__ = true;
var pako_zlib_ZStream = function() {
	this.adler = 0;
	this.data_type = 2;
	this.deflateState = null;
	this.msg = "";
	this.total_out = 0;
	this.avail_out = 0;
	this.next_out = 0;
	this.output = null;
	this.total_in = 0;
	this.avail_in = 0;
	this.next_in = 0;
	this.input = null;
};
pako_zlib_ZStream.__name__ = true;
var sys_FileSystem = function() { };
sys_FileSystem.__name__ = true;
sys_FileSystem.exists = function(path) {
	try {
		js_node_Fs.accessSync(path);
		return true;
	} catch( _ ) {
		return false;
	}
};
sys_FileSystem.isDirectory = function(path) {
	try {
		return js_node_Fs.statSync(path).isDirectory();
	} catch( e ) {
		return false;
	}
};
sys_FileSystem.createDirectory = function(path) {
	try {
		js_node_Fs.mkdirSync(path);
	} catch( e ) {
		var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
		if(e1.code == "ENOENT") {
			sys_FileSystem.createDirectory(js_node_Path.dirname(path));
			js_node_Fs.mkdirSync(path);
		} else {
			var stat;
			try {
				stat = js_node_Fs.statSync(path);
			} catch( _ ) {
				throw e1;
			}
			if(!stat.isDirectory()) {
				throw e1;
			}
		}
	}
};
var sys_io_FileInput = function(fd) {
	this.fd = fd;
	this.pos = 0;
};
sys_io_FileInput.__name__ = true;
sys_io_FileInput.__super__ = haxe_io_Input;
sys_io_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		var buf = new js_node_buffer_Buffer(1);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,0,1,this.pos);
		} catch( e ) {
			var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
		if(bytesRead == 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		this.pos++;
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = new js_node_buffer_Buffer(data.buffer,data.byteOffset,s.length);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,pos,len,this.pos);
		} catch( e ) {
			var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
		if(bytesRead == 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		this.pos += bytesRead;
		return bytesRead;
	}
});
var $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
String.__name__ = true;
Array.__name__ = true;
var __map_reserved = {};
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
var this1 = new Uint16Array(576);
pako_zlib_Trees.static_ltree = this1;
var this2 = new Uint16Array(60);
pako_zlib_Trees.static_dtree = this2;
var this3 = new Uint16Array(512);
pako_zlib_Trees._dist_code = this3;
var this4 = new Uint16Array(258 - 3 + 1);
pako_zlib_Trees._length_code = this4;
var this5 = new Uint16Array(29);
pako_zlib_Trees.base_length = this5;
var this6 = new Uint16Array(30);
pako_zlib_Trees.base_dist = this6;
var buf = pako_zlib_Trees.static_ltree;
var start = buf.byteOffset;
var len = buf.byteLength;
haxe_io_Bytes.ofData(buf.buffer).fill(start,len,0);
var buf1 = pako_zlib_Trees.static_dtree;
var start1 = buf1.byteOffset;
var len1 = buf1.byteLength;
haxe_io_Bytes.ofData(buf1.buffer).fill(start1,len1,0);
var buf2 = pako_zlib_Trees._dist_code;
var start2 = buf2.byteOffset;
var len2 = buf2.byteLength;
haxe_io_Bytes.ofData(buf2.buffer).fill(start2,len2,0);
var buf3 = pako_zlib_Trees._length_code;
var start3 = buf3.byteOffset;
var len3 = buf3.byteLength;
haxe_io_Bytes.ofData(buf3.buffer).fill(start3,len3,0);
var buf4 = pako_zlib_Trees.base_length;
var start4 = buf4.byteOffset;
var len4 = buf4.byteLength;
haxe_io_Bytes.ofData(buf4.buffer).fill(start4,len4,0);
var buf5 = pako_zlib_Trees.base_dist;
var start5 = buf5.byteOffset;
var len5 = buf5.byteLength;
haxe_io_Bytes.ofData(buf5.buffer).fill(start5,len5,0);
pako_zlib_Deflate.configuration_table = [new pako_zlib_Config(0,0,0,0,pako_zlib_Deflate.deflate_stored),new pako_zlib_Config(4,4,8,4,pako_zlib_Deflate.deflate_fast),new pako_zlib_Config(4,5,16,8,pako_zlib_Deflate.deflate_fast),new pako_zlib_Config(4,6,32,32,pako_zlib_Deflate.deflate_fast),new pako_zlib_Config(4,4,16,16,pako_zlib_Deflate.deflate_slow),new pako_zlib_Config(8,16,32,32,pako_zlib_Deflate.deflate_slow),new pako_zlib_Config(8,16,128,128,pako_zlib_Deflate.deflate_slow),new pako_zlib_Config(8,32,128,256,pako_zlib_Deflate.deflate_slow),new pako_zlib_Config(32,128,258,1024,pako_zlib_Deflate.deflate_slow),new pako_zlib_Config(32,258,258,4096,pako_zlib_Deflate.deflate_slow)].slice(0);
Console.formatMode = Console.determineConsoleFormatMode();
Console.logPrefix = "<b,gray>><//> ";
Console.warnPrefix = "<b,yellow>><//> ";
Console.errorPrefix = "<b,red>></b> ";
Console.successPrefix = "<b,light_green>><//> ";
Console.unicodeCompatibilityMode = Sys.systemName() == "Windows" ? 1 : 0;
Console.unicodeCompatibilityEnabled = false;
Console.formatTagPattern = new EReg("(\\\\)?<(/)?([^><{}\\s]*|{[^}<>]*})>","g");
Main.textureAtlasFontVersion = 1;
Main.technique = "msdf";
Main.msdfgenPath = "prebuilt/msdfgen";
Main.localTmpDir = "__glyph-cache";
Main.fontOutputDirectory = "";
Main.sourceTtfPaths = [];
Main.size_px = 32;
Main.fieldRange_px = 2;
Main.maximumTextureSize = 4096;
Main.storeBounds = false;
Main.saveBinary = true;
Main.externalTextures = false;
Main.preserveTmp = false;
format_bmp_Tools.BGRA_MAP = [3,2,1,0];
haxe_io_FPHelper.helper = new DataView(new ArrayBuffer(8));
pako_Deflate.DEFAULT_OPTIONS = { level : -1, method : 8, chunkSize : 16384, windowBits : 15, memLevel : 8, strategy : 0, raw : false, gzip : false, header : null, dictionary : null};
pako_zlib_CRC32.crcTable = pako_zlib_CRC32.makeTable();
pako_zlib_Trees.extra_lbits = haxe_io__$UInt16Array_UInt16Array_$Impl_$.fromArray([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);
pako_zlib_Trees.extra_dbits = haxe_io__$UInt16Array_UInt16Array_$Impl_$.fromArray([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);
pako_zlib_Trees.extra_blbits = haxe_io__$UInt16Array_UInt16Array_$Impl_$.fromArray([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);
pako_zlib_Trees.bl_order = haxe_io__$UInt16Array_UInt16Array_$Impl_$.fromArray([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
pako_zlib_Trees.static_init_done = false;
pako_zlib_Messages.map = (function($this) {
	var $r;
	var _g = new haxe_ds_IntMap();
	_g.h[2] = "need dictionary";
	_g.h[1] = "stream end";
	_g.h[0] = "";
	_g.h[-1] = "file error";
	_g.h[-2] = "stream error";
	_g.h[-3] = "data error";
	_g.h[-4] = "insufficient memory";
	_g.h[-5] = "buffer error";
	_g.h[-6] = "incompatible version";
	$r = _g;
	return $r;
}(this));
Main.main();
})();
