// Generated by Haxe 4.0.0-preview.4+d8e720f
(function () { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}var Node = function(x,y,w,h) {
	this.used = false;
	this.x = x;
	this.y = y;
	this.w = w;
	this.h = h;
};
Node.__name__ = true;
var BinPacker = function() { };
BinPacker.__name__ = true;
BinPacker.fit = function(blocks,w,h) {
	var sortedBlocks = blocks.slice();
	sortedBlocks.sort(function(a,b) {
		if(Math.max(a.w,a.h) > Math.max(b.w,b.h)) {
			return 1;
		} else {
			return -1;
		}
	});
	var fits = [];
	var root = new Node(0,0,w,h);
	var _g = 0;
	while(_g < sortedBlocks.length) {
		var block = sortedBlocks[_g];
		++_g;
		var node = BinPacker.findNode(root,block.w,block.h);
		fits[blocks.indexOf(block)] = node != null ? BinPacker.splitNode(node,block.w,block.h) : null;
	}
	return fits;
};
BinPacker.findNode = function(parent,w,h) {
	if(parent.used) {
		var right = BinPacker.findNode(parent.right,w,h);
		if(right != null) {
			return right;
		} else {
			return BinPacker.findNode(parent.down,w,h);
		}
	} else if(w <= parent.w && h <= parent.h) {
		return parent;
	}
	return null;
};
BinPacker.splitNode = function(node,w,h) {
	node.used = true;
	node.down = new Node(node.x,node.y + h,node.w,node.h - h);
	node.right = new Node(node.x + w,node.y,node.w - w,h);
	return node;
};
var js_node_ChildProcess = require("child_process");
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Sys = function() { };
Sys.__name__ = true;
Sys.environment = function() {
	var m = new haxe_ds_StringMap();
	var _g = 0;
	var _g1 = Reflect.fields(process.env);
	while(_g < _g1.length) {
		var key = _g1[_g];
		++_g;
		var v = process.env[key];
		if(__map_reserved[key] != null) {
			m.setReserved(key,v);
		} else {
			m.h[key] = v;
		}
	}
	return m;
};
Sys.systemName = function() {
	var _g = process.platform;
	switch(_g) {
	case "darwin":
		return "Mac";
	case "freebsd":
		return "BSD";
	case "linux":
		return "Linux";
	case "win32":
		return "Windows";
	default:
		return _g;
	}
};
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.deleteField = function(o,field) {
	if(!Object.prototype.hasOwnProperty.call(o,field)) {
		return false;
	}
	delete(o[field]);
	return true;
};
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw new js__$Boot_HaxeError("EReg::matched");
		}
	}
	,matchedRight: function() {
		if(this.r.m == null) {
			throw new js__$Boot_HaxeError("No string matched");
		}
		var sz = this.r.m.index + this.r.m[0].length;
		return HxOverrides.substr(this.r.s,sz,this.r.s.length - sz);
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw new js__$Boot_HaxeError("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b1 = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b1) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b1;
		}
	}
	,map: function(s,f) {
		var offset = 0;
		var buf_b = "";
		while(true) {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			var p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
			if(!this.r.global) {
				break;
			}
		}
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
};
var Console = function() { };
Console.__name__ = true;
Console.printFormatted = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	s += "<//>";
	var activeFormatFlagStack = new haxe_ds_List();
	var browserFormatArguments = [];
	var result = Console.formatTagPattern.map(s,function(e) {
		var str = e.matched(2);
		str = str.toLowerCase();
		var flag;
		if(str.charAt(0) == "#" || HxOverrides.substr(str,0,3) == "bg#") {
			var hIdx = str.indexOf("#");
			var hex = HxOverrides.substr(str,hIdx + 1,null);
			if(hex.length == 3) {
				var a = hex.split("");
				hex = [a[0],a[0],a[1],a[1],a[2],a[2]].join("");
			}
			if(new EReg("[^0-9a-f]","i").match(hex) || hex.length < 6) {
				flag = "";
			} else {
				var normalized = str.substring(0,hIdx) + "#" + hex;
				flag = normalized;
			}
		} else {
			switch(str) {
			case "!":
				flag = "invert";
				break;
			case "/":
				flag = "reset";
				break;
			case "b":
				flag = "bold";
				break;
			case "bg_gray":
				flag = "bg_light_black";
				break;
			case "gray":
				flag = "light_black";
				break;
			case "i":
				flag = "italic";
				break;
			case "u":
				flag = "underline";
				break;
			default:
				var transformed = str;
				flag = transformed;
			}
		}
		var open = e.matched(1) == null;
		if(flag == "reset") {
			activeFormatFlagStack.clear();
		} else if(open) {
			activeFormatFlagStack.add(flag);
		} else if(flag != "") {
			activeFormatFlagStack.remove(flag);
		} else {
			activeFormatFlagStack.remove(activeFormatFlagStack.last());
		}
		switch(Console.formatMode) {
		case 0:
			if(open) {
				var last = Console.getAsciiFormat(activeFormatFlagStack.last());
				if(last != null) {
					return last;
				} else {
					return "";
				}
			} else {
				return Console.getAsciiFormat("reset") + activeFormatFlagStack.map(function(f) {
					return Console.getAsciiFormat(f);
				}).filter(function(s1) {
					return s1 != null;
				}).join("");
			}
			break;
		case 1:
			var result1 = activeFormatFlagStack.map(function(f1) {
				return Console.getBrowserFormat(f1);
			}).filter(function(s2) {
				return s2 != null;
			}).join(";");
			browserFormatArguments.push(result1);
			return "%c";
		case 2:
			return "";
		}
	});
	if(Console.formatMode == 1) {
		var logArgs = [result].concat(browserFormatArguments);
		switch(outputStream) {
		case 1:
			console.warn.apply(console, logArgs);
			break;
		case 2:
			console.error.apply(console, logArgs);
			break;
		case 0:case 3:
			console.log.apply(console, logArgs);
			break;
		}
		return;
	}
	Console.print(result,outputStream);
};
Console.print = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	if(Console.unicodeCompatibilityMode == 1 && !Console.unicodeCompatibilityEnabled) {
		Console.exec("chcp 65001");
		Console.unicodeCompatibilityEnabled = true;
	}
	switch(outputStream) {
	case 1:case 2:
		new _$Sys_FileOutput(2).writeString(s);
		break;
	case 0:case 3:
		new _$Sys_FileOutput(1).writeString(s);
		break;
	}
};
Console.getAsciiFormat = function(flag) {
	if(flag.charAt(0) == "#") {
		var hex = HxOverrides.substr(flag,1,null);
		return "\x1B[38;5;" + Console.rgbToAscii256(Std.parseInt("0x" + HxOverrides.substr(hex,0,2)),Std.parseInt("0x" + HxOverrides.substr(hex,2,2)),Std.parseInt("0x" + HxOverrides.substr(hex,4,2))) + "m";
	}
	if(HxOverrides.substr(flag,0,3) == "bg#") {
		var hex1 = HxOverrides.substr(flag,3,null);
		return "\x1B[48;5;" + Console.rgbToAscii256(Std.parseInt("0x" + HxOverrides.substr(hex1,0,2)),Std.parseInt("0x" + HxOverrides.substr(hex1,2,2)),Std.parseInt("0x" + HxOverrides.substr(hex1,4,2))) + "m";
	}
	switch(flag) {
	case "bg_black":
		return "\x1B[48;5;" + 0 + "m";
	case "bg_blue":
		return "\x1B[48;5;" + 4 + "m";
	case "bg_cyan":
		return "\x1B[48;5;" + 6 + "m";
	case "bg_green":
		return "\x1B[48;5;" + 2 + "m";
	case "bg_light_black":
		return "\x1B[48;5;" + 8 + "m";
	case "bg_light_blue":
		return "\x1B[48;5;" + 12 + "m";
	case "bg_light_cyan":
		return "\x1B[48;5;" + 14 + "m";
	case "bg_light_green":
		return "\x1B[48;5;" + 10 + "m";
	case "bg_light_magenta":
		return "\x1B[48;5;" + 13 + "m";
	case "bg_light_red":
		return "\x1B[48;5;" + 9 + "m";
	case "bg_light_white":
		return "\x1B[48;5;" + 15 + "m";
	case "bg_light_yellow":
		return "\x1B[48;5;" + 11 + "m";
	case "bg_magenta":
		return "\x1B[48;5;" + 5 + "m";
	case "bg_red":
		return "\x1B[48;5;" + 1 + "m";
	case "bg_white":
		return "\x1B[48;5;" + 7 + "m";
	case "bg_yellow":
		return "\x1B[48;5;" + 3 + "m";
	case "black":
		return "\x1B[38;5;" + 0 + "m";
	case "blink":
		return "\x1B[5m";
	case "blue":
		return "\x1B[38;5;" + 4 + "m";
	case "bold":
		return "\x1B[1m";
	case "cyan":
		return "\x1B[38;5;" + 6 + "m";
	case "dim":
		return "\x1B[2m";
	case "green":
		return "\x1B[38;5;" + 2 + "m";
	case "hidden":
		return "\x1B[8m";
	case "invert":
		return "\x1B[7m";
	case "italic":
		return "\x1B[3m";
	case "light_black":
		return "\x1B[38;5;" + 8 + "m";
	case "light_blue":
		return "\x1B[38;5;" + 12 + "m";
	case "light_cyan":
		return "\x1B[38;5;" + 14 + "m";
	case "light_green":
		return "\x1B[38;5;" + 10 + "m";
	case "light_magenta":
		return "\x1B[38;5;" + 13 + "m";
	case "light_red":
		return "\x1B[38;5;" + 9 + "m";
	case "light_white":
		return "\x1B[38;5;" + 15 + "m";
	case "light_yellow":
		return "\x1B[38;5;" + 11 + "m";
	case "magenta":
		return "\x1B[38;5;" + 5 + "m";
	case "red":
		return "\x1B[38;5;" + 1 + "m";
	case "reset":
		return "\x1B[m";
	case "underline":
		return "\x1B[4m";
	case "white":
		return "\x1B[38;5;" + 7 + "m";
	case "yellow":
		return "\x1B[38;5;" + 3 + "m";
	default:
		return null;
	}
};
Console.rgbToAscii256 = function(r,g,b) {
	var nearIdx = function(c,set) {
		var delta = Infinity;
		var index = -1;
		var _g = 0;
		var _g1 = set.length;
		while(_g < _g1) {
			var i = _g++;
			var d = Math.abs(c - set[i]);
			if(d < delta) {
				delta = d;
				index = i;
			}
		}
		return index;
	};
	var colorSteps = [0,95,135,175,215,255];
	var ir = nearIdx(r,colorSteps);
	var ig = nearIdx(g,colorSteps);
	var ib = nearIdx(b,colorSteps);
	var jr = Math.round((r - 8) / 10);
	if(Math.abs(r - Math.max(Math.min(jr * 10 + 8,238),8)) + Math.abs(g - Math.max(Math.min(Math.round((g - 8) / 10) * 10 + 8,238),8)) + Math.abs(b - Math.max(Math.min(Math.round((b - 8) / 10) * 10 + 8,238),8)) < Math.abs(r - colorSteps[ir]) + Math.abs(g - colorSteps[ig]) + Math.abs(b - colorSteps[ib]) && r == g && g == b) {
		return jr + 232;
	} else {
		return 16 + ir * 36 + ig * 6 + ib;
	}
};
Console.getBrowserFormat = function(flag) {
	if(flag.charAt(0) == "#") {
		return "color: " + flag;
	}
	if(HxOverrides.substr(flag,0,3) == "bg#") {
		return "background-color: " + HxOverrides.substr(flag,2,null);
	}
	if(flag.charAt(0) == "{") {
		return HxOverrides.substr(flag,1,flag.length - 2);
	}
	switch(flag) {
	case "bg_black":
		return "background-color: black";
	case "bg_blue":
		return "background-color: blue";
	case "bg_cyan":
		return "background-color: cyan";
	case "bg_green":
		return "background-color: green";
	case "bg_light_black":
		return "background-color: gray";
	case "bg_light_blue":
		return "background-color: lightBlue";
	case "bg_light_cyan":
		return "background-color: lightCyan";
	case "bg_light_green":
		return "background-color: lightGreen";
	case "bg_light_magenta":
		return "background-color: lightPink";
	case "bg_light_red":
		return "background-color: salmon";
	case "bg_light_white":
		return "background-color: white";
	case "bg_light_yellow":
		return "background-color: lightYellow";
	case "bg_magenta":
		return "background-color: magenta";
	case "bg_red":
		return "background-color: red";
	case "bg_white":
		return "background-color: whiteSmoke";
	case "bg_yellow":
		return "background-color: gold";
	case "black":
		return "color: black";
	case "blink":
		return "text-decoration: blink";
	case "blue":
		return "color: blue";
	case "bold":
		return "font-weight: bold";
	case "cyan":
		return "color: cyan";
	case "dim":
		return "color: gray";
	case "green":
		return "color: green";
	case "hidden":
		return "visibility: hidden; color: white";
	case "invert":
		return "-webkit-filter: invert(100%); filter: invert(100%)";
	case "italic":
		return "font-style: italic";
	case "light_black":
		return "color: gray";
	case "light_blue":
		return "color: lightBlue";
	case "light_cyan":
		return "color: lightCyan";
	case "light_green":
		return "color: lightGreen";
	case "light_magenta":
		return "color: lightPink";
	case "light_red":
		return "color: salmon";
	case "light_white":
		return "color: white";
	case "light_yellow":
		return "color: #ffed88";
	case "magenta":
		return "color: magenta";
	case "red":
		return "color: red";
	case "reset":
		return "";
	case "underline":
		return "text-decoration: underline";
	case "white":
		return "color: whiteSmoke";
	case "yellow":
		return "color: #f5ba00";
	default:
		return null;
	}
};
Console.determineConsoleFormatMode = function() {
	if(typeof(window) != "undefined") {
		return 1;
	}
	var tputColors = Console.exec("tput colors");
	if(tputColors.exit == 0 && Std.parseInt(tputColors.stdout) > 2) {
		return 0;
	}
	var _this = Sys.environment();
	var termEnv = __map_reserved["TERM"] != null ? _this.getReserved("TERM") : _this.h["TERM"];
	if(termEnv != null && new EReg("cygwin|xterm|vt100","").match(termEnv)) {
		return 0;
	}
	return 2;
};
Console.exec = function(cmd,args) {
	var p = js_node_ChildProcess.spawnSync(cmd,args,{ });
	var stdout = p.stdout == null ? "" : p.stdout.toString();
	if(stdout == null) {
		stdout = "";
	}
	return { exit : p.status, stdout : stdout};
};
var Main = function() { };
Main.__name__ = true;
Main.main = function() {
	Console.errorPrefix = "<b><red>></b> ";
	Console.warnPrefix = "<b><yellow>></b> ";
	var msdfBinaryName = Sys.systemName() == "Windows" ? "msdfgen.exe" : "msdfgen";
	var msdfSearchDirectories = [".","msdfgen","prebuilt"];
	var programDirectory = haxe_io_Path.directory(__filename);
	var _g = 0;
	while(_g < msdfSearchDirectories.length) {
		var dir = msdfSearchDirectories[_g];
		++_g;
		var path = haxe_io_Path.join([programDirectory,dir,msdfBinaryName]);
		if(sys_FileSystem.exists(path) && !sys_FileSystem.isDirectory(path)) {
			Main.msdfgenPath = path;
			break;
		}
	}
	var showHelp = false;
	var argHandler_getDoc = function() {
		return "_ <path>                          : Path of TrueType font file (.ttf)\n['--charset'] <path>              : Path of file containing character set\n['--charlist'] <characters>       : List of characters\n['--output-dir', '-o'] <path>     : Sets the path of the output font file. External resources will be saved in the same directory\n['--technique'] <name>            : Font rendering technique, one of: msdf, sdf, bitmap\n['--msdfgen'] <path>              : Path of msdfgen executable\n['--size'] <glyphSize>            : Maximum dimension of a glyph in pixels\n['--pxrange'] <range>             : Specifies the width of the range around the shape between the minimum and maximum representable signed distance in pixels\n['--max-texture-size'] <size>     : Sets the maximum dimension of the texture atlas\n['--bounds'] <enabled>            : Enables storing glyph bounding boxes in the font (default false)\n['--binary'] <enabled>            : Saves the font in the binary format (default true)\n['--external-textures'] <enabled> : When store textures externally when saving in the binary format\n['--help']                        : Shows this help";
	};
	var argHandler_parse = function(__args) {
		var __index = 0;
		while(__index < __args.length) {
			var _g1 = __args[__index++];
			switch(_g1) {
			case "--binary":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.saveBinary = __args[__index] == "true";
				++__index;
				break;
			case "--bounds":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.storeBounds = __args[__index] == "true";
				++__index;
				break;
			case "--charlist":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.charList = __args[__index].split("");
				++__index;
				break;
			case "--charset":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.charsetPath = __args[__index];
				++__index;
				break;
			case "--external-textures":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.externalTextures = __args[__index] == "true";
				++__index;
				break;
			case "--help":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				showHelp = true;
				__index += 0;
				break;
			case "--max-texture-size":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.maximumTextureSize = Std.parseInt(__args[__index]);
				++__index;
				break;
			case "--msdfgen":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.msdfgenPath = __args[__index];
				++__index;
				break;
			case "--pxrange":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.fieldRange_px = Std.parseInt(__args[__index]);
				++__index;
				break;
			case "--size":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.size_px = Std.parseInt(__args[__index]);
				++__index;
				break;
			case "--technique":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.technique = __args[__index];
				++__index;
				break;
			case "--output-dir":case "-o":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				Main.fontOutputDirectory = __args[__index];
				++__index;
				break;
			default:
				var arg = _g1;
				var path1 = arg;
				if(path1.charAt(0) == "-") {
					if(["-help","-h","-?"].indexOf(path1) != -1) {
						showHelp = true;
					} else {
						throw new js__$Boot_HaxeError("Unrecognized argument <b>\"" + path1 + "\"</b>");
					}
				}
				Main.sourceTtfPaths.push(path1);
			}
		}
	};
	var printUsage = function() {
		Console.printFormatted("<b>Usage:</b> <TrueType font path> [options]\n" + "\n",0);
		Console.print(argHandler_getDoc());
		Console.print("\n",0);
		Console.print("\n",0);
	};
	try {
		argHandler_parse(process.argv.slice(2));
		if(showHelp) {
			printUsage();
			process.exit(0);
			return;
		}
		if(!sys_FileSystem.exists(Main.msdfgenPath)) {
			throw new js__$Boot_HaxeError("msdfgen executable was not found at <b>\"" + Main.msdfgenPath + "\"</b> â€“ ensure it is built");
		}
		if(Main.sourceTtfPaths.length == 0) {
			throw new js__$Boot_HaxeError("Path of source TrueType font file is required");
		}
		var _g11 = 0;
		var _g2 = Main.sourceTtfPaths;
		while(_g11 < _g2.length) {
			var ttfPath = _g2[_g11];
			++_g11;
			if(!sys_FileSystem.exists(ttfPath)) {
				throw new js__$Boot_HaxeError("Font file <b>\"" + ttfPath + "\"</b> does not exist");
			}
		}
		if(Main.charList == null) {
			Main.charList = js_node_Fs.readFileSync(Main.charsetPath,{ encoding : "utf8"}).split("");
		}
		if(Main.technique != "msdf") {
			throw new js__$Boot_HaxeError("Font technique <b>\"" + Main.technique + "\"</b> is not implemented");
		}
	} catch( e ) {
		Console.printFormatted(Console.errorPrefix + ("" + Std.string((e instanceof js__$Boot_HaxeError) ? e.val : e)) + "\n",2);
		Console.print("\n",0);
		printUsage();
		process.exit(1);
		return;
	}
	var _g12 = 0;
	var _g21 = Main.sourceTtfPaths;
	while(_g12 < _g21.length) {
		var ttfPath1 = _g21[_g12];
		++_g12;
		sys_FileSystem.createDirectory(Main.localTmpDir);
		var font = [opentype_Opentype.loadSync(ttfPath1)];
		var fontHeight = [font[0].ascender - font[0].descender];
		var fontFileName = haxe_io_Path.withoutDirectory(haxe_io_Path.withoutExtension(ttfPath1));
		var glyphList = Main.charList.filter((function(font1) {
			return function(c) {
				var g = font1[0].charToGlyph(c);
				if(font1[0].hasChar(c)) {
					if(g.xMin != null) {
						return g.name != ".notdef";
					} else {
						return false;
					}
				} else {
					return false;
				}
			};
		})(font));
		var normalizeFUnits = (function(fontHeight1) {
			return function(fUnit) {
				return fUnit / fontHeight1[0];
			};
		})(fontHeight);
		Console.printFormatted(Console.logPrefix + ("" + ("Generating glyphs for <b>\"" + ttfPath1 + "\"</b>")) + "\n",0);
		var imagePath = (function() {
			return function(charCode) {
				return "" + Main.localTmpDir + "/" + charCode + "-" + Main.size_px + ".bmp";
			};
		})();
		var metricsPath = (function() {
			return function(charCode1) {
				return "" + Main.localTmpDir + "/" + charCode1 + "-" + Main.size_px + "-metrics.txt";
			};
		})();
		var _g13 = 0;
		var _g22 = Main.charList;
		while(_g13 < _g22.length) {
			var char = _g22[_g13];
			++_g13;
			var charCode2 = HxOverrides.cca(char,0);
			var cmd = "" + Main.msdfgenPath + " -font " + ttfPath1 + " " + charCode2 + " -size " + Main.size_px + " " + Main.size_px + " -printmetrics -pxrange " + Main.fieldRange_px + " -autoframe -o \"" + imagePath(charCode2) + "\"> \"" + metricsPath(charCode2) + "\"";
			var e1 = js_node_ChildProcess.spawnSync(cmd,{ shell : true, stdio : "inherit"}).status;
			if(e1 != 0) {
				Console.printFormatted(Console.errorPrefix + ("" + ("" + Main.msdfgenPath + " exited with code " + e1)) + "\n",2);
				process.exit(e1);
				return;
			}
		}
		Console.printFormatted(Console.logPrefix + "Reading glyph metrics" + "\n",0);
		var this1 = { };
		var atlasCharacters = this1;
		var _g3 = 0;
		var _g4 = Main.charList;
		while(_g3 < _g4.length) {
			var char1 = _g4[_g3];
			++_g3;
			atlasCharacters[char1] = { advance : 1, glyph : { atlasScale : 0, atlasRect : null, offset : null}};
		}
		var this2 = { };
		var glyphBounds = this2;
		var _g5 = 0;
		var _g6 = Main.charList;
		while(_g5 < _g6.length) {
			var char2 = _g6[_g5];
			++_g5;
			var charCode3 = HxOverrides.cca(char2,0);
			var metricsFileContent = js_node_Fs.readFileSync(metricsPath(charCode3),{ encoding : "utf8"});
			var atlasCharacter = atlasCharacters[char2];
			var varPattern = new EReg("^\\s*(\\w+)\\s*=([^\n]+)","");
			var str = metricsFileContent;
			while(varPattern.match(str)) {
				var name = varPattern.matched(1);
				var value = varPattern.matched(2).split(",").map((function() {
					return function(f) {
						return parseFloat(f);
					};
				})());
				switch(name) {
				case "advance":
					atlasCharacter.advance = normalizeFUnits(value[0] * 64.0);
					break;
				case "bounds":
					glyphBounds[char2] = { l : normalizeFUnits(value[0] * 64.0), b : normalizeFUnits(value[1] * 64.0), r : normalizeFUnits(value[2] * 64.0), t : normalizeFUnits(value[3] * 64.0)};
					break;
				case "scale":
					var tmp = normalizeFUnits(1 / value[0] * 64.0);
					atlasCharacter.glyph.atlasScale = 1 / tmp;
					break;
				case "translate":
					var tmp1 = normalizeFUnits(value[0] * 64.0);
					var tmp2 = normalizeFUnits(value[1] * 64.0);
					atlasCharacter.glyph.offset = { x : tmp1, y : tmp2};
					break;
				}
				str = varPattern.matchedRight();
			}
		}
		Console.printFormatted(Console.logPrefix + "Packing glyphs into texture" + "\n",0);
		var _g7 = [];
		var _g8 = 0;
		while(_g8 < glyphList.length) {
			var _ = glyphList[_g8];
			++_g8;
			_g7.push({ w : Main.size_px, h : Main.size_px});
		}
		var blocks = _g7;
		var atlasW = Main.ceilPot(Main.size_px);
		var atlasH = Main.ceilPot(Main.size_px);
		var mode = -1;
		var fitSucceeded = false;
		while(atlasW <= Main.maximumTextureSize && atlasH <= Main.maximumTextureSize) {
			var nodes = BinPacker.fit(blocks,atlasW,atlasH);
			if(nodes.indexOf(null) != -1) {
				if(mode == -1) {
					atlasW *= 2;
				} else {
					atlasH *= 2;
				}
				mode *= -1;
			} else {
				var _g9 = 0;
				var _g10 = glyphList.length;
				while(_g9 < _g10) {
					var i = _g9++;
					var char3 = glyphList[i];
					var block = blocks[i];
					var node = nodes[i];
					atlasCharacters[char3].glyph.atlasRect = { x : Math.floor(node.x), y : Math.floor(node.y), w : block.w, h : block.h};
				}
				fitSucceeded = true;
				break;
			}
		}
		if(!fitSucceeded) {
			Console.printFormatted(Console.errorPrefix + ("" + ("Could not fit glyphs into " + Main.maximumTextureSize + "x" + Main.maximumTextureSize + " texture - try a smaller character set or reduced glyph size (multi-atlas is not implemented)")) + "\n",2);
			process.exit(1);
		}
		var _g91 = 0;
		var _g101 = Main.charList;
		while(_g91 < _g101.length) {
			var char4 = _g101[_g91];
			++_g91;
			var hasGlyph = glyphList.indexOf(char4) != -1;
			if(!hasGlyph) {
				Reflect.deleteField(atlasCharacters[char4],"glyph");
			}
		}
		var channels = 3;
		var bytesPerChannel = 1;
		var mapRgbBytes = haxe_io_Bytes.ofData(new ArrayBuffer(channels * bytesPerChannel * atlasW * atlasH));
		var _g111 = 0;
		while(_g111 < glyphList.length) {
			var char5 = glyphList[_g111];
			++_g111;
			var charCode4 = HxOverrides.cca(char5,0);
			var input = new sys_io_FileInput(js_node_Fs.openSync(imagePath(charCode4),"r"));
			var bmpData = new format_bmp_Reader(input).read();
			var glyphHeader = bmpData.header;
			var glyphBGRA = format_bmp_Tools._extract32(bmpData,format_bmp_Tools.BGRA_MAP,255);
			var rect = atlasCharacters[char5].glyph.atlasRect;
			var _g112 = 0;
			var _g121 = glyphHeader.width;
			while(_g112 < _g121) {
				var x = _g112++;
				var _g113 = 0;
				var _g122 = glyphHeader.height;
				while(_g113 < _g122) {
					var y = _g113++;
					var i1 = (y * glyphHeader.width + x) * 4;
					var b = glyphBGRA.b[i1];
					var g1 = glyphBGRA.b[i1 + 1];
					var r = glyphBGRA.b[i1 + 2];
					var mx = x + (rect.x | 0);
					var my = y + (rect.y | 0);
					var mi = (my * atlasW + mx) * 3;
					mapRgbBytes.b[mi] = b;
					mapRgbBytes.b[mi + 1] = g1;
					mapRgbBytes.b[mi + 2] = r;
				}
			}
		}
		Console.printFormatted(Console.logPrefix + "Deleting glyph cache" + "\n",0);
		var tmpFiles = js_node_Fs.readdirSync(Main.localTmpDir);
		var _g123 = 0;
		while(_g123 < tmpFiles.length) {
			var name1 = tmpFiles[_g123];
			++_g123;
			try {
				js_node_Fs.unlinkSync(haxe_io_Path.join([Main.localTmpDir,name1]));
			} catch( e2 ) {
				var e3 = (e2 instanceof js__$Boot_HaxeError) ? e2.val : e2;
			}
		}
		var path2 = Main.localTmpDir;
		if(sys_FileSystem.exists(path2)) {
			var _g14 = 0;
			var _g15 = js_node_Fs.readdirSync(path2);
			while(_g14 < _g15.length) {
				var file = _g15[_g14];
				++_g14;
				var curPath = path2 + "/" + file;
				if(sys_FileSystem.isDirectory(curPath)) {
					if(sys_FileSystem.exists(curPath)) {
						var _g16 = 0;
						var _g17 = js_node_Fs.readdirSync(curPath);
						while(_g16 < _g17.length) {
							var file1 = _g17[_g16];
							++_g16;
							var curPath1 = curPath + "/" + file1;
							if(sys_FileSystem.isDirectory(curPath1)) {
								if(sys_FileSystem.exists(curPath1)) {
									var _g18 = 0;
									var _g19 = js_node_Fs.readdirSync(curPath1);
									while(_g18 < _g19.length) {
										var file2 = _g19[_g18];
										++_g18;
										var curPath2 = curPath1 + "/" + file2;
										if(sys_FileSystem.isDirectory(curPath2)) {
											sys_FileSystem.deleteDirectory(curPath2);
										} else {
											js_node_Fs.unlinkSync(curPath2);
										}
									}
									js_node_Fs.rmdirSync(curPath1);
								}
							} else {
								js_node_Fs.unlinkSync(curPath1);
							}
						}
						js_node_Fs.rmdirSync(curPath);
					}
				} else {
					js_node_Fs.unlinkSync(curPath);
				}
			}
			js_node_Fs.rmdirSync(path2);
		}
		var textureFileName = "" + fontFileName + "-0.png";
		var textureFilePath = haxe_io_Path.join([Main.fontOutputDirectory,textureFileName]);
		var pngData = format_png_Tools.buildRGB(atlasW,atlasH,mapRgbBytes,9);
		var pngOutput = new haxe_io_BytesOutput();
		new format_png_Writer(pngOutput).write(pngData);
		var pngBytes = pngOutput.getBytes();
		var this3 = { };
		var kerningMap = this3;
		var _g131 = 0;
		var _g141 = Main.charList;
		while(_g131 < _g141.length) {
			var first = _g141[_g131];
			++_g131;
			var _g132 = 0;
			var _g142 = Main.charList;
			while(_g132 < _g142.length) {
				var second = _g142[_g132];
				++_g132;
				var kerningAmount_fu = font[0].charToGlyph(first);
				var kerningAmount_fu1 = font[0].charToGlyph(second);
				var kerningAmount_fu2 = font[0].getKerningValue(kerningAmount_fu,kerningAmount_fu1);
				if(kerningAmount_fu2 != null && kerningAmount_fu2 != 0) {
					kerningMap[first + second] = normalizeFUnits(kerningAmount_fu2);
				}
			}
		}
		var processFontNameField = (function() {
			return function(field) {
				if(field == null) {
					return null;
				}
				if(field.en == null) {
					return null;
				}
				return StringTools.trim(field.en);
			};
		})();
		var jsonFont = Main.textureAtlasFontVersion;
		var jsonFont1 = font[0].ascender / fontHeight[0];
		var jsonFont2 = font[0].descender / fontHeight[0];
		var jsonFont3 = font[0].tables.os2.sTypoAscender / fontHeight[0];
		var jsonFont4 = font[0].tables.os2.sTypoDescender / fontHeight[0];
		var jsonFont5 = font[0].tables.os2.sxHeight / fontHeight[0];
		var jsonFont6 = processFontNameField(font[0].names.fontFamily);
		var jsonFont7 = processFontNameField(font[0].names.fontSubfamily);
		var jsonFont8 = processFontNameField(font[0].names.version);
		var jsonFont9 = processFontNameField(font[0].names.postScriptName);
		var jsonFont10 = processFontNameField(font[0].names.copyright);
		var jsonFont11 = processFontNameField(font[0].names.trademark);
		var jsonFont12 = processFontNameField(font[0].names.manufacturer);
		var jsonFont13 = processFontNameField(font[0].names.manufacturerURL);
		var jsonFont14 = processFontNameField(font[0].names.designerURL);
		var jsonFont15 = processFontNameField(font[0].names.license);
		var jsonFont16 = processFontNameField(font[0].names.licenseURL);
		var jsonFont17 = { format : "TextureAtlasFontJson", version : jsonFont, technique : "msdf", characters : atlasCharacters, kerning : kerningMap, textures : [[{ localPath : textureFileName}]], textureSize : { w : atlasW, h : atlasH}, ascender : jsonFont1, descender : jsonFont2, typoAscender : jsonFont3, typoDescender : jsonFont4, lowercaseHeight : jsonFont5, metadata : { family : jsonFont6, subfamily : jsonFont7, version : jsonFont8, postScriptName : jsonFont9, copyright : jsonFont10, trademark : jsonFont11, manufacturer : jsonFont12, manufacturerURL : jsonFont13, designerURL : jsonFont14, license : jsonFont15, licenseURL : jsonFont16, height_funits : fontHeight[0], funitsPerEm : font[0].unitsPerEm}, glyphBounds : Main.storeBounds ? glyphBounds : null, fieldRange_px : Main.fieldRange_px};
		if(Main.fontOutputDirectory != "") {
			sys_FileSystem.createDirectory(Main.fontOutputDirectory);
		}
		if(!Main.saveBinary) {
			var fontJsonOutputPath = haxe_io_Path.join([Main.fontOutputDirectory,fontFileName + ".json"]);
			js_node_Fs.writeFileSync(fontJsonOutputPath,JSON.stringify(jsonFont17,null,"\t"));
			Console.printFormatted(Console.successPrefix + ("" + ("Saved <b>\"" + fontJsonOutputPath + "\"</b>")) + "\n",0);
			var data = pngBytes.b;
			js_node_Fs.writeFileSync(textureFilePath,new js_node_buffer_Buffer(data.buffer,data.byteOffset,pngBytes.length));
			Console.printFormatted(Console.successPrefix + ("" + ("Saved <b>\"" + textureFilePath + "\"</b> (" + atlasW + "x" + atlasH + ", " + glyphList.length + " glyphs)")) + "\n",0);
		} else {
			var header = { format : "TextureAtlasFontBinary", version : Main.textureAtlasFontVersion, technique : jsonFont17.technique, ascender : jsonFont17.ascender, descender : jsonFont17.descender, typoAscender : jsonFont17.typoAscender, typoDescender : jsonFont17.typoDescender, lowercaseHeight : jsonFont17.lowercaseHeight, metadata : jsonFont17.metadata, fieldRange_px : jsonFont17.fieldRange_px, textureSize : jsonFont17.textureSize, charList : Main.charList, kerningPairs : Reflect.fields(jsonFont17.kerning), characters : null, kerning : null, glyphBounds : null, textures : null};
			var payload = new haxe_io_BytesOutput();
			var payloadPos = 0;
			var characterDataBytes = new haxe_io_BytesOutput();
			var characterDataLength_bytes = 24;
			var tmp3 = Main.charList.length * characterDataLength_bytes;
			var _g151 = 0;
			var _g161 = Main.charList;
			while(_g151 < _g161.length) {
				var character = _g161[_g151];
				++_g151;
				var characterData = atlasCharacters[character];
				characterDataBytes.writeFloat(characterData.advance);
				var glyph = characterData.glyph != null ? characterData.glyph : { atlasRect : { x : 0, y : 0, w : 0, h : 0}, atlasScale : 0.0, offset : { x : 0.0, y : 0.0}};
				characterDataBytes.writeUInt16(glyph.atlasRect.x);
				characterDataBytes.writeUInt16(glyph.atlasRect.y);
				characterDataBytes.writeUInt16(glyph.atlasRect.w);
				characterDataBytes.writeUInt16(glyph.atlasRect.h);
				characterDataBytes.writeFloat(glyph.atlasScale);
				characterDataBytes.writeFloat(glyph.offset.x);
				characterDataBytes.writeFloat(glyph.offset.y);
			}
			payload.write(characterDataBytes.getBytes());
			header.characters = { start : payloadPos, length : characterDataBytes.b.pos};
			payloadPos = payload.b.pos;
			var kerningBytes = new haxe_io_BytesOutput();
			var kerningDataLength_bytes = 4;
			var tmp4 = kerningDataLength_bytes * Reflect.fields(jsonFont17.kerning).length;
			var _g171 = 0;
			var _g181 = Reflect.fields(jsonFont17.kerning);
			while(_g171 < _g181.length) {
				var k = _g181[_g171];
				++_g171;
				kerningBytes.writeFloat(jsonFont17.kerning[k]);
			}
			payload.write(kerningBytes.getBytes());
			header.kerning = { start : payloadPos, length : kerningBytes.b.pos};
			payloadPos = payload.b.pos;
			if(Main.storeBounds) {
				var boundsBytes = new haxe_io_BytesOutput();
				var boundsDataLength_bytes = 16;
				var tmp5 = boundsDataLength_bytes * Reflect.fields(glyphBounds).length;
				var _g191 = 0;
				var _g20 = Main.charList;
				while(_g191 < _g20.length) {
					var character1 = _g20[_g191];
					++_g191;
					var bounds = glyphBounds[character1];
					if(bounds == null) {
						bounds = { l : 0, r : 0, t : 0, b : 0};
					}
					boundsBytes.writeFloat(bounds.t);
					boundsBytes.writeFloat(bounds.r);
					boundsBytes.writeFloat(bounds.b);
					boundsBytes.writeFloat(bounds.l);
				}
				header.glyphBounds = { start : payloadPos, length : boundsBytes.b.pos};
				payloadPos = payload.b.pos;
			}
			if(Main.externalTextures) {
				var data1 = pngBytes.b;
				js_node_Fs.writeFileSync(textureFilePath,new js_node_buffer_Buffer(data1.buffer,data1.byteOffset,pngBytes.length));
				Console.printFormatted(Console.successPrefix + ("" + ("Saved <b>\"" + textureFilePath + "\"</b> (" + atlasW + "x" + atlasH + ", " + glyphList.length + " glyphs)")) + "\n",0);
				header.textures = [[{ localPath : textureFileName}]];
			} else {
				payload.write(pngBytes);
				header.textures = [[{ payloadBytes : { start : payloadPos, length : pngBytes.length}}]];
				payloadPos = payload.b.pos;
			}
			var binaryFontOutput = new haxe_io_BytesOutput();
			binaryFontOutput.writeString(JSON.stringify(header));
			binaryFontOutput.writeByte(0);
			binaryFontOutput.write(payload.getBytes());
			var fontBinOutputPath = haxe_io_Path.join([Main.fontOutputDirectory,fontFileName + "." + Main.technique + ".bin"]);
			var bytes = binaryFontOutput.getBytes();
			var data2 = bytes.b;
			js_node_Fs.writeFileSync(fontBinOutputPath,new js_node_buffer_Buffer(data2.buffer,data2.byteOffset,bytes.length));
			Console.printFormatted(Console.successPrefix + ("" + ("Saved <b>\"" + fontBinOutputPath + "\"</b>")) + "\n",0);
		}
	}
};
Main.ceilPot = function(x) {
	return Math.pow(2,Math.ceil(Math.log(x) / Math.log(2))) | 0;
};
Math.__name__ = true;
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,set_bigEndian: function(b) {
		this.bigEndian = b;
		return b;
	}
	,write: function(s) {
		var l = s.length;
		var p = 0;
		while(l > 0) {
			var k = this.writeBytes(s,p,l);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			p += k;
			l -= k;
		}
	}
	,writeFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	,writeFloat: function(x) {
		this.writeInt32(haxe_io_FPHelper.floatToI32(x));
	}
	,writeUInt16: function(x) {
		if(x < 0 || x >= 65536) {
			throw new js__$Boot_HaxeError(haxe_io_Error.Overflow);
		}
		if(this.bigEndian) {
			this.writeByte(x >> 8);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8);
		}
	}
	,writeInt32: function(x) {
		if(this.bigEndian) {
			this.writeByte(x >>> 24);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >>> 24);
		}
	}
	,writeString: function(s,encoding) {
		var b = haxe_io_Bytes.ofString(s,encoding);
		this.writeFullBytes(b,0,b.length);
	}
};
var _$Sys_FileOutput = function(fd) {
	this.fd = fd;
};
_$Sys_FileOutput.__name__ = true;
_$Sys_FileOutput.__super__ = haxe_io_Output;
_$Sys_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		js_node_Fs.writeSync(this.fd,String.fromCodePoint(c));
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		return js_node_Fs.writeSync(this.fd,new js_node_buffer_Buffer(data.buffer,data.byteOffset,s.length),pos,len);
	}
	,writeString: function(s,encoding) {
		js_node_Fs.writeSync(this.fd,s);
	}
});
var haxe_io_Input = function() { };
haxe_io_Input.__name__ = true;
haxe_io_Input.prototype = {
	readByte: function() {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,readBytes: function(s,pos,len) {
		var k = len;
		var b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( eof ) {
			if(!((eof instanceof js__$Boot_HaxeError) ? eof.val : eof instanceof haxe_io_Eof)) {
				throw eof;
			}
		}
		return len - k;
	}
	,readFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.readBytes(s,pos,len);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			pos += k;
			len -= k;
		}
	}
	,readInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var n = this.bigEndian ? ch2 | ch1 << 8 : ch1 | ch2 << 8;
		if((n & 32768) != 0) {
			return n - 65536;
		}
		return n;
	}
	,readInt32: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var ch3 = this.readByte();
		var ch4 = this.readByte();
		if(this.bigEndian) {
			return ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16 | ch4 << 24;
		}
	}
};
var format_bmp_Reader = function(i) {
	this.input = i;
};
format_bmp_Reader.__name__ = true;
format_bmp_Reader.prototype = {
	read: function() {
		if(this.input.readByte() != 66) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		if(this.input.readByte() != 77) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var fileSize = this.input.readInt32();
		this.input.readInt32();
		var offset = this.input.readInt32();
		this.input.readInt32();
		var width = this.input.readInt32();
		var height = this.input.readInt32();
		this.input.readInt16();
		var bits = this.input.readInt16();
		var compression = this.input.readInt32();
		var dataLength = this.input.readInt32();
		this.input.readInt32();
		this.input.readInt32();
		this.input.readInt32();
		this.input.readInt32();
		if(compression == 0 && dataLength == 0) {
			dataLength = fileSize - offset;
		}
		if(bits != 24) {
			throw new js__$Boot_HaxeError("" + bits + "bpp bitmaps not implemented.");
		}
		var p = new haxe_io_Bytes(new ArrayBuffer(dataLength));
		var topToBottom = false;
		if(height < 0) {
			topToBottom = true;
			height = -height;
		}
		this.input.readFullBytes(p,0,dataLength);
		return { header : { width : width, height : height, paddedStride : (width * bits + 31 & -32) >> 3, topToBottom : topToBottom, bpp : bits, dataLength : dataLength}, pixels : p};
	}
};
var format_bmp_Tools = function() { };
format_bmp_Tools.__name__ = true;
format_bmp_Tools._extract32 = function(bmp,channelMap,alpha) {
	if(alpha == null) {
		alpha = 255;
	}
	var srcBytes = bmp.pixels;
	var dstLen = bmp.header.width * bmp.header.height * 4;
	var dstBytes = new haxe_io_Bytes(new ArrayBuffer(dstLen));
	var srcStride = bmp.header.width * 3;
	var srcPaddedStride = bmp.header.paddedStride;
	var yDir = -1;
	var dstPos = 0;
	var srcPos = bmp.header.dataLength - srcPaddedStride;
	if(bmp.header.topToBottom) {
		yDir = 1;
		srcPos = 0;
	}
	while(dstPos < dstLen) {
		var i = srcPos;
		while(i < srcPos + srcStride) {
			var b = srcBytes.b[i];
			var g = srcBytes.b[i + 1];
			var r = srcBytes.b[i + 2];
			dstBytes.b[dstPos + channelMap[0]] = alpha;
			dstBytes.b[dstPos + channelMap[1]] = r;
			dstBytes.b[dstPos + channelMap[2]] = g;
			dstBytes.b[dstPos + channelMap[3]] = b;
			i += 3;
			dstPos += 4;
		}
		srcPos += yDir * srcPaddedStride;
	}
	return dstBytes;
};
var format_png_Color = $hxEnums["format.png.Color"] = { __ename__ : true, __constructs__ : ["ColGrey","ColTrue","ColIndexed"]
	,ColGrey: ($_=function(alpha) { return {_hx_index:0,alpha:alpha,__enum__:"format.png.Color",toString:$estr}; },$_.__params__ = ["alpha"],$_)
	,ColTrue: ($_=function(alpha) { return {_hx_index:1,alpha:alpha,__enum__:"format.png.Color",toString:$estr}; },$_.__params__ = ["alpha"],$_)
	,ColIndexed: {_hx_index:2,__enum__:"format.png.Color",toString:$estr}
};
var format_png_Chunk = $hxEnums["format.png.Chunk"] = { __ename__ : true, __constructs__ : ["CEnd","CHeader","CData","CPalette","CUnknown"]
	,CEnd: {_hx_index:0,__enum__:"format.png.Chunk",toString:$estr}
	,CHeader: ($_=function(h) { return {_hx_index:1,h:h,__enum__:"format.png.Chunk",toString:$estr}; },$_.__params__ = ["h"],$_)
	,CData: ($_=function(b) { return {_hx_index:2,b:b,__enum__:"format.png.Chunk",toString:$estr}; },$_.__params__ = ["b"],$_)
	,CPalette: ($_=function(b) { return {_hx_index:3,b:b,__enum__:"format.png.Chunk",toString:$estr}; },$_.__params__ = ["b"],$_)
	,CUnknown: ($_=function(id,data) { return {_hx_index:4,id:id,data:data,__enum__:"format.png.Chunk",toString:$estr}; },$_.__params__ = ["id","data"],$_)
};
var format_png_Tools = function() { };
format_png_Tools.__name__ = true;
format_png_Tools.buildRGB = function(width,height,data,level) {
	if(level == null) {
		level = 9;
	}
	var rgb = new haxe_io_Bytes(new ArrayBuffer(width * height * 3 + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	while(_g < height) {
		++_g;
		rgb.b[w++] = 0;
		var _g1 = 0;
		while(_g1 < width) {
			++_g1;
			rgb.b[w++] = data.b[r + 2];
			rgb.b[w++] = data.b[r + 1];
			rgb.b[w++] = data.b[r];
			r += 3;
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColTrue(false), interlaced : false}));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
var format_png_Writer = function(o) {
	this.o = o;
	o.set_bigEndian(true);
};
format_png_Writer.__name__ = true;
format_png_Writer.prototype = {
	write: function(png) {
		this.o.writeByte(137);
		this.o.writeByte(80);
		this.o.writeByte(78);
		this.o.writeByte(71);
		this.o.writeByte(13);
		this.o.writeByte(10);
		this.o.writeByte(26);
		this.o.writeByte(10);
		var _g_head = png.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			switch(val._hx_index) {
			case 0:
				this.writeChunk("IEND",new haxe_io_Bytes(new ArrayBuffer(0)));
				break;
			case 1:
				var h = val.h;
				var b = new haxe_io_BytesOutput();
				b.set_bigEndian(true);
				b.writeInt32(h.width);
				b.writeInt32(h.height);
				b.writeByte(h.colbits);
				var _g = h.color;
				var tmp;
				switch(_g._hx_index) {
				case 0:
					tmp = _g.alpha ? 4 : 0;
					break;
				case 1:
					tmp = _g.alpha ? 6 : 2;
					break;
				case 2:
					tmp = 3;
					break;
				}
				b.writeByte(tmp);
				b.writeByte(0);
				b.writeByte(0);
				b.writeByte(h.interlaced ? 1 : 0);
				this.writeChunk("IHDR",b.getBytes());
				break;
			case 2:
				this.writeChunk("IDAT",val.b);
				break;
			case 3:
				this.writeChunk("PLTE",val.b);
				break;
			case 4:
				this.writeChunk(val.id,val.data);
				break;
			}
		}
	}
	,writeChunk: function(id,data) {
		this.o.writeInt32(data.length);
		this.o.writeString(id);
		this.o.write(data);
		var crc = new haxe_crypto_Crc32();
		crc.byte(HxOverrides.cca(id,0));
		crc.byte(HxOverrides.cca(id,1));
		crc.byte(HxOverrides.cca(id,2));
		crc.byte(HxOverrides.cca(id,3));
		crc.update(data,0,data.length);
		this.o.writeInt32(crc.get());
	}
};
var format_tools_Deflate = function() { };
format_tools_Deflate.__name__ = true;
format_tools_Deflate.run = function(b,level) {
	if(level == null) {
		level = 9;
	}
	return haxe_zip_Compress.run(b,level);
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_crypto_Crc32 = function() {
	this.crc = -1;
};
haxe_crypto_Crc32.__name__ = true;
haxe_crypto_Crc32.prototype = {
	byte: function(b) {
		var tmp = (this.crc ^ b) & 255;
		if((tmp & 1) == 1) {
			tmp = tmp >>> 1 ^ -306674912;
		} else {
			tmp >>>= 1;
		}
		if((tmp & 1) == 1) {
			tmp = tmp >>> 1 ^ -306674912;
		} else {
			tmp >>>= 1;
		}
		if((tmp & 1) == 1) {
			tmp = tmp >>> 1 ^ -306674912;
		} else {
			tmp >>>= 1;
		}
		if((tmp & 1) == 1) {
			tmp = tmp >>> 1 ^ -306674912;
		} else {
			tmp >>>= 1;
		}
		if((tmp & 1) == 1) {
			tmp = tmp >>> 1 ^ -306674912;
		} else {
			tmp >>>= 1;
		}
		if((tmp & 1) == 1) {
			tmp = tmp >>> 1 ^ -306674912;
		} else {
			tmp >>>= 1;
		}
		if((tmp & 1) == 1) {
			tmp = tmp >>> 1 ^ -306674912;
		} else {
			tmp >>>= 1;
		}
		if((tmp & 1) == 1) {
			tmp = tmp >>> 1 ^ -306674912;
		} else {
			tmp >>>= 1;
		}
		this.crc = this.crc >>> 8 ^ tmp;
	}
	,update: function(b,pos,len) {
		var b1 = b.b.bufferValue;
		var _g = pos;
		var _g1 = pos + len;
		while(_g < _g1) {
			var tmp = (this.crc ^ b1.bytes[_g++]) & 255;
			if((tmp & 1) == 1) {
				tmp = tmp >>> 1 ^ -306674912;
			} else {
				tmp >>>= 1;
			}
			if((tmp & 1) == 1) {
				tmp = tmp >>> 1 ^ -306674912;
			} else {
				tmp >>>= 1;
			}
			if((tmp & 1) == 1) {
				tmp = tmp >>> 1 ^ -306674912;
			} else {
				tmp >>>= 1;
			}
			if((tmp & 1) == 1) {
				tmp = tmp >>> 1 ^ -306674912;
			} else {
				tmp >>>= 1;
			}
			if((tmp & 1) == 1) {
				tmp = tmp >>> 1 ^ -306674912;
			} else {
				tmp >>>= 1;
			}
			if((tmp & 1) == 1) {
				tmp = tmp >>> 1 ^ -306674912;
			} else {
				tmp >>>= 1;
			}
			if((tmp & 1) == 1) {
				tmp = tmp >>> 1 ^ -306674912;
			} else {
				tmp >>>= 1;
			}
			if((tmp & 1) == 1) {
				tmp = tmp >>> 1 ^ -306674912;
			} else {
				tmp >>>= 1;
			}
			this.crc = this.crc >>> 8 ^ tmp;
		}
	}
	,get: function() {
		return this.crc ^ -1;
	}
};
var haxe_ds_List = function() {
	this.length = 0;
};
haxe_ds_List.__name__ = true;
haxe_ds_List.prototype = {
	add: function(item) {
		var x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,last: function() {
		if(this.q == null) {
			return null;
		} else {
			return this.q.item;
		}
	}
	,clear: function() {
		this.h = null;
		this.q = null;
		this.length = 0;
	}
	,remove: function(v) {
		var prev = null;
		var l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
	,iterator: function() {
		return new haxe_ds__$List_ListIterator(this.h);
	}
	,join: function(sep) {
		var s_b = "";
		var first = true;
		var l = this.h;
		while(l != null) {
			if(first) {
				first = false;
			} else {
				s_b += sep == null ? "null" : "" + sep;
			}
			s_b += Std.string(l.item);
			l = l.next;
		}
		return s_b;
	}
	,filter: function(f) {
		var l2 = new haxe_ds_List();
		var l = this.h;
		while(l != null) {
			var v = l.item;
			l = l.next;
			if(f(v)) {
				l2.add(v);
			}
		}
		return l2;
	}
	,map: function(f) {
		var b = new haxe_ds_List();
		var l = this.h;
		while(l != null) {
			var v = l.item;
			l = l.next;
			b.add(f(v));
		}
		return b;
	}
};
var haxe_ds__$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
haxe_ds__$List_ListNode.__name__ = true;
var haxe_ds__$List_ListIterator = function(head) {
	this.head = head;
};
haxe_ds__$List_ListIterator.__name__ = true;
haxe_ds__$List_ListIterator.prototype = {
	hasNext: function() {
		return this.head != null;
	}
	,next: function() {
		var val = this.head.item;
		this.head = this.head.next;
		return val;
	}
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.alloc = function(length) {
	return new haxe_io_Bytes(new ArrayBuffer(length));
};
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i1 = 0;
	while(i1 < s.length) {
		var c1 = s.charCodeAt(i1++);
		if(55296 <= c1 && c1 <= 56319) {
			c1 = c1 - 55232 << 10 | s.charCodeAt(i1++) & 1023;
		}
		if(c1 <= 127) {
			a.push(c1);
		} else if(c1 <= 2047) {
			a.push(192 | c1 >> 6);
			a.push(128 | c1 & 63);
		} else if(c1 <= 65535) {
			a.push(224 | c1 >> 12);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		} else {
			a.push(240 | c1 >> 18);
			a.push(128 | c1 >> 12 & 63);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new haxe_io_Bytes(b);
};
haxe_io_Bytes.ofHex = function(s) {
	if((s.length & 1) != 0) {
		throw new js__$Boot_HaxeError("Not a hex string (odd number of digits)");
	}
	var a = [];
	var i = 0;
	var len = s.length >> 1;
	while(i < len) {
		var high = s.charCodeAt(i * 2);
		var low = s.charCodeAt(i * 2 + 1);
		high = (high & 15) + ((high & 64) >> 6) * 9;
		low = (low & 15) + ((low & 64) >> 6) * 9;
		a.push((high << 4 | low) & 255);
		++i;
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.fastGet = function(b,pos) {
	return b.bytes[pos];
};
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
haxe_io_BytesBuffer.__name__ = true;
haxe_io_BytesBuffer.prototype = {
	addByte: function(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	,addBytes: function(src,pos,len) {
		if(pos < 0 || len < 0 || pos + len > src.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(this.pos + len > this.size) {
			this.grow(len);
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset + pos,len);
		this.u8.set(sub,this.pos);
		this.pos += len;
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
};
var haxe_io_BytesOutput = function() {
	this.b = new haxe_io_BytesBuffer();
};
haxe_io_BytesOutput.__name__ = true;
haxe_io_BytesOutput.__super__ = haxe_io_Output;
haxe_io_BytesOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		this.b.addByte(c);
	}
	,writeBytes: function(buf,pos,len) {
		this.b.addBytes(buf,pos,len);
		return len;
	}
	,getBytes: function() {
		return this.b.getBytes();
	}
});
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
var haxe_io_Eof = function() {
};
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var haxe_io_FPHelper = function() { };
haxe_io_FPHelper.__name__ = true;
haxe_io_FPHelper.floatToI32 = function(f) {
	haxe_io_FPHelper.helper.setFloat32(0,f,true);
	return haxe_io_FPHelper.helper.getInt32(0,true);
};
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
haxe_io_Path.__name__ = true;
haxe_io_Path.withoutExtension = function(path) {
	var s = new haxe_io_Path(path);
	s.ext = null;
	return s.toString();
};
haxe_io_Path.withoutDirectory = function(path) {
	var s = new haxe_io_Path(path);
	s.dir = null;
	return s.toString();
};
haxe_io_Path.directory = function(path) {
	var s = new haxe_io_Path(path);
	if(s.dir == null) {
		return "";
	}
	return s.dir;
};
haxe_io_Path.join = function(paths) {
	var paths1 = paths.filter(function(s) {
		if(s != null) {
			return s != "";
		} else {
			return false;
		}
	});
	if(paths1.length == 0) {
		return "";
	}
	var path = paths1[0];
	var _g = 1;
	var _g1 = paths1.length;
	while(_g < _g1) {
		path = haxe_io_Path.addTrailingSlash(path);
		path += paths1[_g++];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	path = path.split("\\").join("/");
	if(path == "/") {
		return "/";
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split("/");
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join("/");
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g2 = 0;
	var _g3 = tmp.length;
	while(_g2 < _g3) {
		var _g21 = tmp.charCodeAt(_g2++);
		switch(_g21) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(_g21);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCodePoint(_g21);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
haxe_io_Path.prototype = {
	toString: function() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
};
var haxe_zip_Compress = function() { };
haxe_zip_Compress.__name__ = true;
haxe_zip_Compress.run = function(s,level) {
	var data = s.b;
	return js_node_buffer__$Buffer_Helper.bytesOfBuffer(js_node_Zlib.deflateSync(new js_node_buffer_Buffer(data.buffer,data.byteOffset,s.length),{ level : level}));
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s += "\t";
				var tmp = n + "(";
				var _g = [];
				var _g1 = 0;
				var _g2 = con.__params__;
				while(_g1 < _g2.length) {
					var p = _g2[_g1];
					++_g1;
					_g.push(js_Boot.__string_rec(o[p],s));
				}
				return tmp + _g.join(",") + ")";
			} else {
				return n;
			}
		}
		if((o instanceof Array)) {
			var l = o.length;
			var i;
			var str = "[";
			s += "\t";
			var _g3 = 0;
			var _g11 = l;
			while(_g3 < _g11) {
				var i1 = _g3++;
				str += (i1 > 0 ? "," : "") + js_Boot.__string_rec(o[i1],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			var e2 = (e1 instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_node_Fs = require("fs");
var js_node_Path = require("path");
var js_node_Zlib = require("zlib");
var js_node_buffer_Buffer = require("buffer").Buffer;
var js_node_buffer__$Buffer_Helper = function() { };
js_node_buffer__$Buffer_Helper.__name__ = true;
js_node_buffer__$Buffer_Helper.bytesOfBuffer = function(b) {
	var o = Object.create(haxe_io_Bytes.prototype);
	o.length = b.byteLength;
	o.b = b;
	b.bufferValue = b;
	b.hxBytes = o;
	b.bytes = b;
	return o;
};
var opentype_Opentype = require("opentype");
var sys_FileSystem = function() { };
sys_FileSystem.__name__ = true;
sys_FileSystem.exists = function(path) {
	try {
		js_node_Fs.accessSync(path);
		return true;
	} catch( _ ) {
		return false;
	}
};
sys_FileSystem.isDirectory = function(path) {
	try {
		return js_node_Fs.statSync(path).isDirectory();
	} catch( e ) {
		return false;
	}
};
sys_FileSystem.createDirectory = function(path) {
	try {
		js_node_Fs.mkdirSync(path);
	} catch( e ) {
		var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
		if(e1.code == "ENOENT") {
			sys_FileSystem.createDirectory(js_node_Path.dirname(path));
			js_node_Fs.mkdirSync(path);
		} else {
			var stat;
			try {
				stat = js_node_Fs.statSync(path);
			} catch( _ ) {
				throw e1;
			}
			if(!stat.isDirectory()) {
				throw e1;
			}
		}
	}
};
sys_FileSystem.deleteDirectory = function(path) {
	if(sys_FileSystem.exists(path)) {
		var _g = 0;
		var _g1 = js_node_Fs.readdirSync(path);
		while(_g < _g1.length) {
			var curPath = path + "/" + _g1[_g++];
			if(sys_FileSystem.isDirectory(curPath)) {
				if(sys_FileSystem.exists(curPath)) {
					var _g2 = 0;
					var _g11 = js_node_Fs.readdirSync(curPath);
					while(_g2 < _g11.length) {
						var curPath1 = curPath + "/" + _g11[_g2++];
						if(sys_FileSystem.isDirectory(curPath1)) {
							if(sys_FileSystem.exists(curPath1)) {
								var _g3 = 0;
								var _g12 = js_node_Fs.readdirSync(curPath1);
								while(_g3 < _g12.length) {
									var curPath2 = curPath1 + "/" + _g12[_g3++];
									if(sys_FileSystem.isDirectory(curPath2)) {
										sys_FileSystem.deleteDirectory(curPath2);
									} else {
										js_node_Fs.unlinkSync(curPath2);
									}
								}
								js_node_Fs.rmdirSync(curPath1);
							}
						} else {
							js_node_Fs.unlinkSync(curPath1);
						}
					}
					js_node_Fs.rmdirSync(curPath);
				}
			} else {
				js_node_Fs.unlinkSync(curPath);
			}
		}
		js_node_Fs.rmdirSync(path);
	}
};
var sys_io_FileInput = function(fd) {
	this.fd = fd;
	this.pos = 0;
};
sys_io_FileInput.__name__ = true;
sys_io_FileInput.__super__ = haxe_io_Input;
sys_io_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		var buf = new js_node_buffer_Buffer(1);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,0,1,this.pos);
		} catch( e ) {
			var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
		if(bytesRead == 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		this.pos++;
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = new js_node_buffer_Buffer(data.buffer,data.byteOffset,s.length);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,pos,len,this.pos);
		} catch( e ) {
			var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
		if(bytesRead == 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		this.pos += bytesRead;
		return bytesRead;
	}
});
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
var __map_reserved = {};
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
Console.formatMode = Console.determineConsoleFormatMode();
Console.logPrefix = "<b><gray>><//> ";
Console.warnPrefix = "<b><yellow>><//> ";
Console.errorPrefix = "<b><red>><//> ";
Console.successPrefix = "<b><light_green>><//> ";
Console.unicodeCompatibilityMode = Sys.systemName() == "Windows" ? 1 : 0;
Console.unicodeCompatibilityEnabled = false;
Console.formatTagPattern = new EReg("<(/)?([^><{}\\s]*|{[^}<>]*})>","g");
Main.textureAtlasFontVersion = 1;
Main.technique = "msdf";
Main.msdfgenPath = "prebuilt/msdfgen";
Main.charsetPath = "charsets/ascii.txt";
Main.localTmpDir = "__glyph-cache";
Main.fontOutputDirectory = "";
Main.sourceTtfPaths = [];
Main.size_px = 32;
Main.fieldRange_px = 2;
Main.maximumTextureSize = 4096;
Main.storeBounds = false;
Main.saveBinary = true;
Main.externalTextures = false;
format_bmp_Tools.BGRA_MAP = [3,2,1,0];
haxe_io_FPHelper.helper = new DataView(new ArrayBuffer(8));
Main.main();
})();
